<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h2>连接设置</h2>

        <!-- 连接状态 -->
        <div class="status" id="connectionStatus">未连接</div>
        <div class="network-info" id="networkInfo">
            网络状态: 检测中...
            <div class="connection-quality">
                <span>连接质量:</span>
                <div class="quality-indicator" id="qualityIndicator"></div>
                <span id="qualityText">未连接</span>
            </div>
        </div>

        <!-- 连接选项卡 -->
        <div class="connection-tabs">
            <div class="connection-tab active" data-tab="connect">连接</div>
            <div class="connection-tab" data-tab="chats">联系人</div>
            <div class="connection-tab" data-tab="groups">群聊</div>
        </div>

        <!-- 连接面板 -->
        <div class="connection-panel active" id="connectPanel">
            <!-- 用户ID显示 -->
            <div class="user-id" id="userId">
                您的ID: <span id="userIdValue">生成中...</span>
                <button id="copyIdBtn" style="padding: 2px 5px; font-size: 12px; margin-left: 5px;">复制</button>
            </div>

            <div class="steps">
                <div class="step">
                    <div class="step-number">1</div>
                    <button onclick="ConnectionManager.createOffer()" id="createOfferBtn">创建连接请求</button>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <button onclick="ConnectionManager.createAnswer()" id="createAnswerBtn">创建连接响应</button>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <button onclick="ConnectionManager.handleAnswer()" id="handleAnswerBtn">处理对方响应</button>
                </div>
                <!-- 添加重置按钮 -->
                <div class="reset-container">
                    <button id="resetAllBtn" class="reset-all-btn">重置</button>
                </div>
            </div>

            <div class="connection-info">
                <h3>连接信息</h3>
                <label for="sdpText"></label><textarea id="sdpText" placeholder="粘贴对方的连接信息..."></textarea>
                <button onclick="UIManager.copyText()" class="copy-button">复制连接信息</button>
            </div>

            <div class="debug-info" id="debugInfo"></div>
        </div>

        <!-- 联系人列表面板 -->
        <div class="connection-panel" id="chatsPanel">

            <div class="chat-actions">
                <button id="newChatBtn" class="new-chat-btn">添加新聊天</button>
                <button id="clearContactsBtn" class="clear-contacts-btn">清空联系人列表</button>
            </div>

            <!-- 新建聊天表单 -->
            <div class="new-chat-form" id="newChatForm">
                <label for="peerIdInput"></label><input type="text" id="peerIdInput" placeholder="输入对方ID">
                <label for="peerNameInput"></label><input type="text" id="peerNameInput" placeholder="输入对方昵称">
                <div class="form-buttons">
                    <button class="cancel-btn" id="cancelNewChatBtn">取消</button>
                    <button id="confirmNewChatBtn">确认</button>
                </div>
            </div>

            <!-- 联系人列表 -->
            <div class="chat-list" id="chatList">
                <!-- 聊天项会动态添加 -->
            </div>
        </div>
        <!-- 群聊面板 -->
        <div class="connection-panel" id="groupsPanel">
            <div class="group-actions">
                <button id="newGroupBtn" class="new-group-btn">创建新群聊</button>
            </div>

            <!-- 新建群聊表单 -->
            <div class="new-group-form" id="newGroupForm" style="display: none;">
                <input type="text" id="groupNameInput" placeholder="输入群聊名称">
                <div class="form-buttons">
                    <button class="cancel-btn" id="cancelNewGroupBtn">取消</button>
                    <button id="confirmNewGroupBtn">确认</button>
                </div>
            </div>

            <!-- 群聊列表 -->
            <div class="group-list" id="groupList">
                <!-- 群聊项会动态添加 -->
            </div>
        </div>
    </div>

    <div class="chat-container">
        <!-- 添加返回设置按钮 -->
        <button class="back-to-settings" id="backToSettings">返回连接设置</button>

        <!-- 聊天头部 -->
        <div class="chat-header">
            <div class="chat-title" id="currentChatTitle">未选择聊天</div>
            <div class="chat-actions" id="chatHeaderActions" style="display: none;">
                <button id="manageMembersBtn" class="manage-members-btn">管理成员</button>
            </div>
        </div>

        <!-- 群聊成员管理弹窗 -->
        <div id="memberManagementModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <h3>管理群聊成员</h3>
                <div class="member-list" id="groupMemberList">
                    <!-- 成员列表会动态添加 -->
                </div>
                <div class="add-member-section">
                    <h4>添加成员</h4>
                    <div class="add-member-form">
                        <label for="contactsDropdown"></label><select id="contactsDropdown">
                            <option value="">选择联系人...</option>
                        </select>
                        <button id="addMemberBtn">添加</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-box" id="chatBox"></div>

        <div class="input-area">
            <!-- 添加媒体按钮行 -->
            <div class="media-controls">
                <div class="left-buttons">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()" id="uploadButton" disabled>
                        文件
                    </button>
                    <button class="voice-record-button" id="voiceButton" disabled>
                        <span id="voiceButtonText">录音</span>
                        <span id="voiceTimer" class="audio-timer" style="display: none">00:00</span>
                    </button>
                    <button class="video-call-btn" id="videoCallButton" disabled onclick="VideoCallManager.initiateCall()">
                        视频
                    </button>
                    <button class="audio-call-btn" id="audioCallButton" disabled onclick="VideoCallManager.initiateAudioCall()">
                        语音通话
                    </button>
                </div>
                <div class="right-buttons">
                    <button class="clear-chat-btn" id="clearChatButton" onclick="MessageManager.clearChat()">
                        清空会话
                    </button>
                </div>
            </div>

            <!-- 文本输入行 -->
            <div class="input-controls">
                <label for="messageInput"></label><textarea id="messageInput" placeholder="输入消息... (Ctrl+Enter 发送)" disabled></textarea>
                <button id="sendButton" disabled onclick="MessageManager.sendMessage()">发送</button>
            </div>

            <input type="file" id="fileInput" style="display: none"
                   onchange="MediaManager.handleFileSelect(event)">
            <div id="filePreviewContainer"></div>
            <div id="audioPreviewContainer"></div>
        </div>
    </div>
</div>
<!-- 视频通话请求弹窗 -->
<div id="videoCallRequest" class="video-call-request" style="display: none;">
    <div class="video-call-avatar">👤</div>
    <h3>视频通话请求</h3>
    <p>对方请求与您进行视频通话</p>
    <div class="video-call-request-buttons">
        <button class="reject-call" onclick="VideoCallManager.rejectCall()">拒绝</button>
        <button class="accept-call" onclick="VideoCallManager.acceptCall()">接受</button>
    </div>
</div>

<!-- 视频通话界面 -->
<div id="videoCallContainer" class="video-call-container" style="display: none;">
    <div class="video-streams">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="video-call-controls">
        <button class="video-call-button toggle-camera" id="toggleCameraBtn" onclick="VideoCallManager.toggleCamera()">
            📹
        </button>
        <button class="video-call-button mute-audio" id="toggleAudioBtn" onclick="VideoCallManager.toggleAudio()">
            🎤
        </button>
        <button class="video-call-button end-call" onclick="VideoCallManager.endCall()">
            📞
        </button>
        <button class="video-call-button audio-only" id="audioOnlyBtn" onclick="VideoCallManager.toggleAudioOnly()">
            🔊
        </button>
    </div>
</div>
</body>

<script>
    // 配置对象
    const Config = {
        // ICE服务器配置
        iceServers: [
            {
                "urls": [
                    "turn:stun.evan-brass.net",
                    "turn:stun.evan-brass.net?transport=tcp",
                    "stun:stun.evan-brass.net"
                ],
                "username": "guest",
                "credential": "password"
            }
        ],

        // WebRTC配置
        peerConnectionConfig: {
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            iceCandidatePoolSize: 10,
            sdpSemantics: 'unified-plan'
        },

        // 重连配置
        reconnect: {
            maxAttempts: 5,
            delay: 2000,
            backoffFactor: 1.5
        },

        // 超时配置
        timeouts: {
            iceGathering: 5000,  // 更低的超时，快速失败
            connection: 8000,
            networkCheck: 5000
        },

        // 媒体配置
        media: {
            maxAudioDuration: 60,  // 60秒
            imageCompression: 0.7  // 默认压缩率
        }
    };

    // 工具类
    const Utils = {
        // 日志级别
        logLevels: {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3
        },

        // 当前日志级别
        currentLogLevel: 0,

        // 记录日志
        log: function (message, level = this.logLevels.DEBUG) {
            if (level >= this.currentLogLevel) {
                const debugInfo = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();

                let prefix = '';
                switch (level) {
                    case this.logLevels.INFO:
                        prefix = '[信息] ';
                        break;
                    case this.logLevels.WARN:
                        prefix = '[警告] ';
                        break;
                    case this.logLevels.ERROR:
                        prefix = '[错误] ';
                        break;
                    default:
                        prefix = '[调试] ';
                }

                debugInfo.innerHTML = `[${timestamp}] ${prefix}${message}<br>` + debugInfo.innerHTML;

                // 限制日志条数
                const lines = debugInfo.innerHTML.split('<br>');
                if (lines.length > 10) {
                    debugInfo.innerHTML = lines.slice(0, 10).join('<br>');
                }

                // 在控制台也记录日志
                if (level === this.logLevels.ERROR) {
                    console.error(message);
                } else if (level === this.logLevels.WARN) {
                    console.warn(message);
                } else {
                    console.log(message);
                }
            }
        },

        // 格式化时间
        formatTime: function (seconds) {
            const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${minutes}:${secs}`;
        },

        // 网络类型检测
        checkNetworkType: async function () {
            try {
                const pc = new RTCPeerConnection();
                const candidates = [];

                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        candidates.push(e.candidate);
                    }
                };

                await pc.createDataChannel("");
                await pc.createOffer().then(offer => pc.setLocalDescription(offer));
                await new Promise(r => setTimeout(r, 1000));

                pc.close();

                const hasIPv4 = candidates.some(c => c.address && c.address.indexOf('.') !== -1);
                const hasIPv6 = candidates.some(c => c.address && c.address.indexOf(':') !== -1);
                const hasRelay = candidates.some(c => c.type === 'relay');
                const hasUdp = candidates.some(c => c.protocol === 'udp');
                const hasTcp = candidates.some(c => c.protocol === 'tcp');

                return {
                    ipv4: hasIPv4,
                    ipv6: hasIPv6,
                    relay: hasRelay,
                    udp: hasUdp,
                    tcp: hasTcp,
                    count: candidates.length
                };
            } catch (error) {
                Utils.log(`网络检测失败: ${error.message}`, Utils.logLevels.ERROR);
                return null;
            }
        },

        // 分块发送大文件
        sendInChunks: function (data, sendFunc, chunkSize = 128 * 1024) {
            // 如果数据小于阈值，直接发送
            if (data.length < chunkSize) {
                return sendFunc(data);
            }

            // 否则分块发送
            const chunks = [];
            const totalChunks = Math.ceil(data.length / chunkSize);
            const fileId = new Date().getTime();

            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(data.length, start + chunkSize);
                chunks.push(data.substring(start, end));
            }

            Utils.log(`文件过大，分为${totalChunks}块发送`, Utils.logLevels.INFO);

            // 发送元数据
            sendFunc(JSON.stringify({
                type: 'file-meta',
                id: fileId,
                totalChunks: totalChunks
            }));

            // 逐块发送
            chunks.forEach((chunk, index) => {
                setTimeout(() => {
                    sendFunc(JSON.stringify({
                        type: 'file-chunk',
                        id: fileId,
                        chunk: chunk,
                        index: index
                    }));
                }, index * 100); // 添加小延迟避免发送过快
            });
        },

        // 生成随机ID
        generateId: function() {
            return Math.random().toString(36).substring(2, 10);
        },

        // 格式化日期
        formatDate: function(date) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.getTime() > today.getTime()) {
                return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            } else if (date.getTime() > yesterday.getTime()) {
                return '昨天';
            } else {
                return `${date.getMonth() + 1}月${date.getDate()}日`;
            }
        }
    };

    // 事件管理器
    const EventEmitter = {
        events: {},

        // 注册事件
        on: function (event, callback) {
            if (!this.events[event]) {
                this.events[event] = [];
            }
            this.events[event].push(callback);
        },

        // 触发事件
        emit: function (event, ...args) {
            if (this.events[event]) {
                this.events[event].forEach(callback => {
                    try {
                        callback(...args);
                    } catch (e) {
                        Utils.log(`事件处理发生错误: ${e.message}`, Utils.logLevels.ERROR);
                    }
                });
            }
        },

        // 移除事件
        off: function (event, callback) {
            if (this.events[event]) {
                if (callback) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                } else {
                    delete this.events[event];
                }
            }
        }
    };

    // 数据库管理器
    const DBManager = {
        db: null,
        dbName: 'p2pChatDB',
        dbVersion: 1,

        // 初始化数据库
        init: function() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    resolve(this.db);
                    return;
                }

                const request = indexedDB.open(this.dbName, this.dbVersion);

                request.onerror = (event) => {
                    Utils.log('数据库打开失败', Utils.logLevels.ERROR);
                    reject('数据库打开失败');
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    Utils.log('数据库打开成功', Utils.logLevels.INFO);
                    resolve(this.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // 创建用户存储
                    if (!db.objectStoreNames.contains('user')) {
                        db.createObjectStore('user', { keyPath: 'id' });
                    }

                    // 创建联系人存储
                    if (!db.objectStoreNames.contains('contacts')) {
                        db.createObjectStore('contacts', { keyPath: 'id' });
                    }

                    // 创建聊天记录存储
                    if (!db.objectStoreNames.contains('chats')) {
                        db.createObjectStore('chats', { keyPath: 'id' });
                    }

                    // 创建群组存储
                    if (!db.objectStoreNames.contains('groups')) {
                        db.createObjectStore('groups', { keyPath: 'id' });
                    }
                };
            });
        },

        // 存储数据
        setItem: function(storeName, item) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('数据库未初始化');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(item);

                request.onsuccess = () => resolve();
                request.onerror = () => reject('存储数据失败');
            });
        },

        // 获取数据
        getItem: function(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('数据库未初始化');
                    return;
                }

                const transaction = this.db.transaction([storeName]);
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject('获取数据失败');
            });
        },

        // 获取存储中的所有数据
        getAllItems: function(storeName) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('数据库未初始化');
                    return;
                }

                const transaction = this.db.transaction([storeName]);
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject('获取数据失败');
            });
        },

        // 删除数据
        removeItem: function(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('数据库未初始化');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject('删除数据失败');
            });
        },

        // 清空存储
        clearStore: function(storeName) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('数据库未初始化');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject('清空数据失败');
            });
        }
    };

    // 连接管理器
    const ConnectionManager = {
        connections: {},  // 存储多个连接
        iceCandidates: {},
        connectionTimeouts: {},
        reconnectAttempts: {},
        iceTimers: {},
        iceGatheringStartTimes: {},
        connectionStrengths: {},
        pendingChunks: {},

        // 初始化连接
        init: function (peerId) {
            if (this.connections[peerId]) {
                this.close(peerId);
            }

            try {
                // 创建新的配置，基于当前网络状况
                let currentConfig = {...Config.peerConnectionConfig};
                currentConfig.iceServers = Config.iceServers;

                this.connections[peerId] = {
                    peerConnection: new RTCPeerConnection(currentConfig),
                    dataChannel: null
                };

                const pc = this.connections[peerId].peerConnection;

                pc.onicecandidate = (e) => this.handleIceCandidate(e, peerId);
                pc.onicegatheringstatechange = (e) => this.handleIceGatheringStateChange(e, peerId);
                pc.oniceconnectionstatechange = (e) => this.handleIceConnectionStateChange(e, peerId);
                pc.ondatachannel = (e) => this.handleDataChannel(e, peerId);

                this.iceCandidates[peerId] = [];
                this.reconnectAttempts[peerId] = 0;

                Utils.log(`与${peerId}的WebRTC连接已初始化`, Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`初始化连接失败: ${error.message}`, Utils.logLevels.ERROR);
                return false;
            }
        },

        // 处理ICE候选者
        handleIceCandidate: function (event, peerId) {
            if (event.candidate) {
                if (!this.iceCandidates[peerId]) {
                    this.iceCandidates[peerId] = [];
                }
                this.iceCandidates[peerId].push(event.candidate);
                this.updateSdpText();
                Utils.log(`收集到ICE候选: ${event.candidate.type} ${event.candidate.protocol}`, Utils.logLevels.DEBUG);

                // 如果连接已建立，尝试发送候选者给对方（启用Trickle ICE）
                const conn = this.connections[peerId];
                if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    this.sendIceCandidate(event.candidate, peerId);
                }
            }
        },

        // 处理ICE收集状态变化
        handleIceGatheringStateChange: function (event, peerId) {
            const pc = this.connections[peerId]?.peerConnection;
            if (!pc) return;

            const state = pc.iceGatheringState;

            switch (state) {
                case 'gathering':
                    UIManager.updateStatus('正在收集网络信息...');
                    this.startIceTimer(peerId);
                    this.iceGatheringStartTimes[peerId] = Date.now();
                    break;

                case 'complete':
                    this.stopIceTimer(peerId);
                    const duration = (Date.now() - this.iceGatheringStartTimes[peerId]) / 1000;
                    UIManager.updateStatus(`网络信息收集完成 (${duration.toFixed(1)}秒)`);
                    this.updateSdpText();
                    break;
            }
        },

        // 处理ICE连接状态变化
        handleIceConnectionStateChange: function (event, peerId) {
            const pc = this.connections[peerId]?.peerConnection;
            if (!pc) return;

            const state = pc.iceConnectionState;
            UIManager.updateStatus(`ICE状态: ${state}`);

            switch (state) {
                case 'checking':
                    this.startConnectionTimeout(peerId);
                    EventEmitter.emit('connectionChecking', peerId);
                    break;

                case 'connected':
                    this.clearConnectionTimeout(peerId);
                    this.enableTrickleIce(peerId);
                    this.connectionStrengths[peerId] = this.calculateConnectionStrength(peerId);
                    UIManager.updateConnectionState(true);
                    EventEmitter.emit('connectionEstablished', peerId);

                    // 更新视频通话按钮状态
                    if (ChatManager.currentChatId === peerId) {
                        document.getElementById('videoCallButton').disabled = false;
                        document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);
                    }
                    break;

                case 'disconnected':
                    this.handleDisconnection(peerId);
                    EventEmitter.emit('connectionDisconnected', peerId);
                    break;

                case 'failed':
                    this.handleConnectionFailure(peerId);
                    EventEmitter.emit('connectionFailed', peerId);
                    break;

                case 'closed':
                    UIManager.updateConnectionState(false);
                    EventEmitter.emit('connectionClosed', peerId);
                    break;
            }
        },

        // 处理数据通道
        handleDataChannel: function (event, peerId) {
            this.setupDataChannel(event.channel, peerId);
        },

        // 启动ICE收集计时器
        startIceTimer: function (peerId) {
            this.stopIceTimer(peerId);
            this.iceTimers[peerId] = setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceGatheringState !== 'complete') {
                    Utils.log('ICE收集超时，使用当前可用连接', Utils.logLevels.WARN);
                    UIManager.updateStatus('网络信息收集超时，使用当前可用连接');
                    this.updateSdpText();
                }
            }, Config.timeouts.iceGathering);
        },

        // 停止ICE收集计时器
        stopIceTimer: function (peerId) {
            if (this.iceTimers[peerId]) {
                clearTimeout(this.iceTimers[peerId]);
                this.iceTimers[peerId] = null;
            }
        },

        // 启动连接超时
        startConnectionTimeout: function (peerId) {
            this.clearConnectionTimeout(peerId);
            this.connectionTimeouts[peerId] = setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceConnectionState === 'checking') {
                    Utils.log('连接建立超时', Utils.logLevels.WARN);
                    this.handleConnectionFailure(peerId);
                }
            }, Config.timeouts.connection);
        },

        // 清除连接超时
        clearConnectionTimeout: function (peerId) {
            if (this.connectionTimeouts[peerId]) {
                clearTimeout(this.connectionTimeouts[peerId]);
                this.connectionTimeouts[peerId] = null;
            }
        },

        // 处理连接失败
        handleConnectionFailure: function (peerId) {
            UIManager.updateStatus('连接失败');
            UIManager.updateConnectionState(false);

            if (!this.reconnectAttempts[peerId]) {
                this.reconnectAttempts[peerId] = 0;
            }

            if (this.reconnectAttempts[peerId] < Config.reconnect.maxAttempts) {
                const delay = Config.reconnect.delay * Math.pow(Config.reconnect.backoffFactor, this.reconnectAttempts[peerId]);
                this.reconnectAttempts[peerId]++;

                UIManager.updateStatus(`正在尝试重新连接 (${this.reconnectAttempts[peerId]}/${Config.reconnect.maxAttempts})...`, delay);

                setTimeout(() => {
                    this.restartIceWithRelay(peerId);
                }, delay);
            } else {
                UIManager.updateStatus('连接失败，请重新开始连接流程');
                this.resetConnection(peerId);
            }
        },

        // 处理连接断开
        handleDisconnection: function (peerId) {
            UIManager.updateStatus('连接断开，尝试重连...');
            UIManager.updateConnectionState(false, 'disconnected');

            // 使用指数退避重连
            const delay = 1000;
            setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceConnectionState === 'disconnected') {
                    this.restartIce(peerId);
                }
            }, delay);
        },

        // 使用中继服务器重启ICE
        restartIceWithRelay: async function (peerId) {
            try {
                const conn = this.connections[peerId];
                if (!conn || !conn.peerConnection) {
                    throw new Error('没有活动的连接');
                }

                // 调整配置，强制使用中继
                const relayConfig = {
                    ...Config.peerConnectionConfig,
                    iceTransportPolicy: 'relay'
                };
                relayConfig.iceServers = Config.iceServers;

                conn.peerConnection.setConfiguration(relayConfig);

                Utils.log('正在使用中继服务器重新协商连接', Utils.logLevels.INFO);

                if (conn.peerConnection.signalingState === 'stable') {
                    const offer = await conn.peerConnection.createOffer({iceRestart: true});
                    await conn.peerConnection.setLocalDescription(offer);
                    UIManager.updateStatus('正在尝试使用中继服务器重连...');
                    this.updateSdpText();
                }
            } catch (error) {
                Utils.log(`重连尝试失败: ${error.message}`, Utils.logLevels.ERROR);
                // 继续尝试下一次重连或最终放弃
                this.handleConnectionFailure(peerId);
            }
        },

        // 标准ICE重启
        restartIce: async function (peerId) {
            try {
                const conn = this.connections[peerId];
                if (!conn || !conn.peerConnection || conn.peerConnection.signalingState !== 'stable') {
                    return;
                }

                Utils.log('正在尝试ICE重启', Utils.logLevels.INFO);

                const offer = await conn.peerConnection.createOffer({iceRestart: true});
                await conn.peerConnection.setLocalDescription(offer);

                this.updateSdpText();
                UIManager.updateStatus('正在协商重新连接...');
            } catch (error) {
                Utils.log(`ICE重启失败: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // 启用Trickle ICE（实时发送ICE候选者）
        enableTrickleIce: function (peerId) {
            Utils.log('启用Trickle ICE', Utils.logLevels.DEBUG);
            // 已在handleIceCandidate处理
        },

        // 发送ICE候选者
        sendIceCandidate: function (candidate, peerId) {
            const conn = this.connections[peerId];
            if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                try {
                    const message = {
                        type: 'ice-candidate',
                        candidate: candidate,
                        sender: UserManager.userId
                    };
                    conn.dataChannel.send(JSON.stringify(message));
                    Utils.log('已发送ICE候选', Utils.logLevels.DEBUG);
                } catch (error) {
                    Utils.log(`发送ICE候选失败: ${error.message}`, Utils.logLevels.ERROR);
                }
            }
        },

        // 设置数据通道
        setupDataChannel: function (channel, peerId) {
            if (!this.connections[peerId]) {
                this.connections[peerId] = { peerConnection: null, dataChannel: null };
            }

            this.connections[peerId].dataChannel = channel;
            const conn = this.connections[peerId];

            conn.dataChannel.onopen = () => {
                Utils.log(`与${peerId}的数据通道已打开`, Utils.logLevels.INFO);
                UIManager.updateStatus("连接已建立，可以开始聊天");
                UIManager.enableChatInterface(true);
                EventEmitter.emit('dataChannelOpen', peerId);

                // 首次连接成功后自动交换更多ICE候选
                this.enableTrickleIce(peerId);

                // 开始连接质量监控
                this.startConnectionMonitoring(peerId);

                // 如果当前正在查看该联系人的聊天，启用视频通话按钮
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);
                }
            };

            conn.dataChannel.onclose = () => {
                Utils.log(`与${peerId}的数据通道已关闭`, Utils.logLevels.INFO);
                UIManager.updateStatus("连接已关闭");

                // 如果当前正在查看该联系人的聊天，禁用视频通话按钮
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = true;
                }

                EventEmitter.emit('dataChannelClosed', peerId);
            };

            conn.dataChannel.onmessage = (event) => {
                try {
                    // 尝试解析JSON消息
                    const message = JSON.parse(event.data);

                    // 添加发送者信息
                    if (!message.sender) {
                        message.sender = peerId;
                    }

                    // 添加时间戳
                    if (!message.timestamp) {
                        message.timestamp = new Date().toISOString();
                    }

                    // 检查是否是群组相关消息
                    if (message.groupId ||
                        message.type === 'group-invite' ||
                        message.type === 'group-removed' ||
                        message.type === 'group-member-added' ||
                        message.type === 'group-member-removed') {

                        // 交给群聊管理器处理
                        if (GroupManager.handleGroupMessage(message)) {
                            return; // 已处理群聊消息
                        }
                    }

                    // 检查是否是视频通话相关消息
                    if (message.type && message.type.startsWith('video-call-')) {
                        VideoCallManager.handleMessage(message, peerId);
                        return;
                    }

                    switch (message.type) {
                        case 'ice-candidate':
                            this.handleIncomingIceCandidate(message.candidate, peerId);
                            break;

                        case 'file-meta':
                            // 初始化文件块收集
                            if (!this.pendingChunks[peerId]) {
                                this.pendingChunks[peerId] = {};
                            }
                            this.pendingChunks[peerId][message.id] = {
                                chunks: new Array(message.totalChunks),
                                received: 0,
                                total: message.totalChunks
                            };
                            break;

                        case 'file-chunk':
                            // 收集文件块
                            if (this.pendingChunks[peerId] && this.pendingChunks[peerId][message.id]) {
                                this.pendingChunks[peerId][message.id].chunks[message.index] = message.chunk;
                                this.pendingChunks[peerId][message.id].received++;

                                // 检查是否已收到所有块
                                if (this.pendingChunks[peerId][message.id].received === this.pendingChunks[peerId][message.id].total) {
                                    const completeData = this.pendingChunks[peerId][message.id].chunks.join('');
                                    delete this.pendingChunks[peerId][message.id];

                                    // 解析并显示完整消息
                                    const fullMessage = JSON.parse(completeData);
                                    fullMessage.sender = peerId;

                                    // 添加到聊天记录并显示
                                    ChatManager.addMessage(peerId, fullMessage);

                                    // 更新联系人最后消息
                                    let previewText = '[文件]';
                                    if (fullMessage.type === 'file' || fullMessage.type === 'image') {
                                        if (fullMessage.fileType) {
                                            if (fullMessage.fileType.startsWith('image/')) previewText = '[图片]';
                                            else if (fullMessage.fileType.startsWith('video/')) previewText = '[视频]';
                                            else if (fullMessage.fileType.startsWith('audio/')) previewText = '[音频]';
                                        }
                                    }
                                    else if (fullMessage.type === 'audio') previewText = '[语音]';

                                    UserManager.updateContactLastMessage(
                                        peerId,
                                        previewText,
                                        ChatManager.currentChatId !== peerId
                                    );
                                }
                            }
                            break;

                        default:
                            // 普通消息添加到聊天记录
                            ChatManager.addMessage(peerId, message);

                            // 更新联系人最后消息
                            let previewText = '';
                            if (message.type === 'text') {
                                previewText = message.content;
                            } else if (message.type === 'file' || message.type === 'image') {
                                if (message.fileType) {
                                    if (message.fileType.startsWith('image/')) previewText = '[图片]';
                                    else if (message.fileType.startsWith('video/')) previewText = '[视频]';
                                    else if (message.fileType.startsWith('audio/')) previewText = '[音频]';
                                    else previewText = '[文件]';
                                } else {
                                    previewText = '[文件]';
                                }
                            } else if (message.type === 'audio') {
                                previewText = '[语音]';
                            } else {
                                previewText = '[消息]';
                            }

                            UserManager.updateContactLastMessage(
                                peerId,
                                previewText,
                                ChatManager.currentChatId !== peerId
                            );
                    }
                } catch (e) {
                    // 如果不是JSON，作为普通文本显示
                    const textMessage = {
                        type: 'text',
                        content: event.data,
                        sender: peerId,
                        timestamp: new Date().toISOString()
                    };
                    ChatManager.addMessage(peerId, textMessage);
                    UserManager.updateContactLastMessage(
                        peerId,
                        event.data,
                        ChatManager.currentChatId !== peerId
                    );
                }
            };

            conn.dataChannel.onerror = (error) => {
                Utils.log(`数据通道错误: ${error.message || '未知错误'}`, Utils.logLevels.ERROR);
                EventEmitter.emit('dataChannelError', error, peerId);
            };
        },

        // 处理接收到的ICE候选者
        handleIncomingIceCandidate: async function (candidate, peerId) {
            try {
                const conn = this.connections[peerId];
                if (conn && conn.peerConnection) {
                    await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    Utils.log('已添加远程ICE候选', Utils.logLevels.DEBUG);
                }
            } catch (error) {
                Utils.log(`添加远程ICE候选失败: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // 开始连接质量监测
        startConnectionMonitoring: function (peerId) {
            setInterval(async () => {
                const conn = this.connections[peerId];
                if (conn && conn.peerConnection && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    try {
                        const stats = await conn.peerConnection.getStats();
                        let currentRoundTripTime = null;
                        let bytesReceived = 0;
                        let bytesSent = 0;
                        let localCandidateType = null;
                        let remoteCandidateType = null;

                        stats.forEach(report => {
                            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                currentRoundTripTime = report.currentRoundTripTime;
                                // 保存UDP或TCP连接类型
                                if (report.localCandidateId && report.remoteCandidateId) {
                                    stats.forEach(s => {
                                        if (s.id === report.localCandidateId) {
                                            localCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                        if (s.id === report.remoteCandidateId) {
                                            remoteCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                    });
                                }
                            }

                            if (report.type === 'data-channel') {
                                bytesReceived += report.bytesReceived || 0;
                                bytesSent += report.bytesSent || 0;
                            }
                        });

                        // 只在有效RTT时更新连接质量
                        if (currentRoundTripTime !== null) {
                            UIManager.updateConnectionQuality(currentRoundTripTime);
                            this.connectionStrengths[peerId] = this.calculateConnectionStrength(peerId, currentRoundTripTime);

                            Utils.log(`连接监测: RTT=${currentRoundTripTime.toFixed(3)}s, 本地=${localCandidateType}, 远程=${remoteCandidateType}, 传输=${bytesReceived + bytesSent}字节`,
                                Utils.logLevels.DEBUG);

                            // 如果连接质量很差，尝试重新协商
                            if (currentRoundTripTime > 1.5 && this.connectionStrengths[peerId] < 30) {
                                this.considerReconnection(peerId);
                            }
                        }
                    } catch (error) {
                        Utils.log(`获取连接统计失败: ${error.message}`, Utils.logLevels.ERROR);
                    }
                }
            }, Config.timeouts.networkCheck);
        },

        // 计算连接强度 (0-100)
        calculateConnectionStrength: function (peerId, rtt = null) {
            const conn = this.connections[peerId];
            if (!conn || !conn.peerConnection) return 0;

            let strength = 0;

            // 基于ICE连接状态
            switch (conn.peerConnection.iceConnectionState) {
                case 'connected':
                    strength += 60;
                    break;
                case 'completed':
                    strength += 70;
                    break;
                case 'checking':
                    strength += 30;
                    break;
                case 'disconnected':
                    strength += 10;
                    break;
                default:
                    strength += 0;
            }

            // 如果RTT可用，根据延迟调整
            if (rtt !== null) {
                if (rtt < 0.1) strength += 30;
                else if (rtt < 0.3) strength += 20;
                else if (rtt < 0.7) strength += 10;
                else if (rtt > 1.0) strength -= 20;
            }

            // 确保在0-100范围内
            return Math.max(0, Math.min(100, strength));
        },

        // 在连接质量差时考虑重连
        considerReconnection: function (peerId) {
            if (!this.reconnectAttempts[peerId]) {
                this.reconnectAttempts[peerId] = 0;
            }

            if (this.reconnectAttempts[peerId] < Config.reconnect.maxAttempts) {
                Utils.log('检测到连接质量差，尝试重新协商...', Utils.logLevels.WARN);
                this.restartIce(peerId);
            }
        },

        // 更新SDP文本
        updateSdpText: function (peerId) {
            if (!peerId || !this.connections[peerId]) return;

            const conn = this.connections[peerId];
            if (!conn.peerConnection || !conn.peerConnection.localDescription) {
                return;
            }

            const connectionInfo = {
                sdp: conn.peerConnection.localDescription,
                candidates: this.iceCandidates[peerId] || [],
                userId: UserManager.userId
            };

            document.getElementById('sdpText').value = JSON.stringify(connectionInfo);
        },

        // 重置连接
        resetConnection: function (peerId) {
            if (this.connections[peerId]) {
                this.close(peerId);
            }

            this.connections[peerId] = null;
            this.iceCandidates[peerId] = [];
            this.reconnectAttempts[peerId] = 0;

            if (this.currentPeerId === peerId) {
                UIManager.resetConnectionControls();
            }
        },

        // 关闭连接
        close: function (peerId) {
            this.stopIceTimer(peerId);
            this.clearConnectionTimeout(peerId);

            const conn = this.connections[peerId];
            if (!conn) return;

            if (conn.dataChannel) {
                try {
                    conn.dataChannel.close();
                } catch (e) {
                    // 忽略关闭错误
                }
                conn.dataChannel = null;
            }

            if (conn.peerConnection) {
                try {
                    conn.peerConnection.close();
                } catch (e) {
                    // 忽略关闭错误
                }
                conn.peerConnection = null;
            }

            if (this.currentPeerId === peerId) {
                UIManager.updateStatus('连接已关闭');
                UIManager.enableChatInterface(false);
            }
        },

        // 检查是否已连接到特定用户
        isConnectedTo: function(peerId) {
            const conn = this.connections[peerId];
            return conn &&
                conn.dataChannel &&
                conn.dataChannel.readyState === 'open' &&
                conn.peerConnection &&
                (conn.peerConnection.iceConnectionState === 'connected' ||
                    conn.peerConnection.iceConnectionState === 'completed');
        },

        // 创建连接请求
        createOffer: async function () {
            if (!UIManager.checkWebRTCSupport()) return;

            // 获取对方ID
            const peerIdInput = document.getElementById('sdpText').value.trim();
            let targetPeerId = '';

            if (peerIdInput) {
                try {
                    // 尝试从SDP文本中提取用户ID
                    const sdpData = JSON.parse(peerIdInput);
                    if (sdpData.userId) {
                        targetPeerId = sdpData.userId;
                    }
                } catch (e) {
                    // 解析失败，可能不是有效的JSON
                }
            }

            // 如果没有获取到ID，使用当前选择的聊天ID或请求用户输入
            if (!targetPeerId) {
                if (ChatManager.currentChatId) {
                    targetPeerId = ChatManager.currentChatId;
                } else {
                    targetPeerId = prompt('请输入要连接的用户ID:');
                    if (!targetPeerId) return;
                }
            }

            try {
                if (!this.init(targetPeerId)) {
                    throw new Error('无法初始化WebRTC连接');
                }

                const conn = this.connections[targetPeerId];

                // 创建数据通道
                conn.dataChannel = conn.peerConnection.createDataChannel("messageChannel", {
                    ordered: true,
                    maxRetransmits: 30
                });

                this.setupDataChannel(conn.dataChannel, targetPeerId);

                // 创建offer
                const offer = await conn.peerConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false
                });

                await conn.peerConnection.setLocalDescription(offer);
                UIManager.updateStatus("正在收集网络信息...");

                // 短暂延迟后更新SDP（让ICE收集开始）
                setTimeout(() => this.updateSdpText(targetPeerId), 1000);

                // 只禁用当前操作的按钮，不影响其他连接
                UIManager.disableConnectionButtons('offer');

                // 如果用户不在联系人列表中，添加
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`创建连接请求失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus('创建连接请求失败');
            }
        },

        // 创建连接响应
        createAnswer: async function () {
            try {
                // 解析对方的SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                document.getElementById('sdpText').value = '';
                if (!sdpText) {
                    throw new Error('请先粘贴对方的连接信息');
                }

                const offerData = JSON.parse(sdpText);

                if (!offerData.sdp) {
                    throw new Error('无效的连接信息格式');
                }

                // 获取对方ID
                const targetPeerId = offerData.userId || prompt('请输入对方的用户ID:');
                if (!targetPeerId) {
                    throw new Error('需要对方ID才能建立连接');
                }

                if (!this.init(targetPeerId)) {
                    throw new Error('无法初始化WebRTC连接');
                }

                const conn = this.connections[targetPeerId];

                // 设置远程描述
                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.sdp));

                // 添加ICE候选者
                if (offerData.candidates && offerData.candidates.length > 0) {
                    for (const candidate of offerData.candidates) {
                        await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                // 创建应答
                const answer = await conn.peerConnection.createAnswer();
                await conn.peerConnection.setLocalDescription(answer);

                UIManager.updateStatus("正在收集网络信息...");

                // 短暂延迟后更新SDP
                setTimeout(() => this.updateSdpText(targetPeerId), 1000);

                UIManager.disableConnectionButtons('answer');

                // 如果用户不在联系人列表中，添加
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`创建连接响应失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`创建连接响应失败: ${error.message}`);
            }
        },

        // 处理连接响应
        handleAnswer: async function () {
            try {
                // 解析对方的SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                if (!sdpText) {
                    throw new Error('请先粘贴对方的连接信息');
                }

                const answerData = JSON.parse(sdpText);

                if (!answerData.sdp) {
                    throw new Error('无效的连接信息格式');
                }

                // 获取对方ID
                const targetPeerId = answerData.userId;
                if (!targetPeerId) {
                    throw new Error('连接信息中缺少用户ID');
                }

                if (!this.connections[targetPeerId]) {
                    throw new Error('未找到与该用户的连接，请先创建连接请求');
                }

                const conn = this.connections[targetPeerId];

                // 设置远程描述
                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.sdp));

                // 添加ICE候选者
                if (answerData.candidates && answerData.candidates.length > 0) {
                    for (const candidate of answerData.candidates) {
                        await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                UIManager.updateStatus("正在建立连接...");
                UIManager.disableConnectionButtons('complete');
                // 清空连接信息
                document.getElementById('sdpText').value = "";

                // 如果用户不在联系人列表中，添加
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`处理连接响应失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`处理连接响应失败: ${error.message}`);
            }
        },

        // 向特定用户发送消息
        sendTo: function(peerId, message) {
            const conn = this.connections[peerId];
            if (!conn || !conn.dataChannel || conn.dataChannel.readyState !== 'open') {
                UIManager.showNotification(`无法发送消息，与${peerId}的连接未建立`, 'error');
                return false;
            }

            try {
                // 确保消息是对象
                let msgToSend = message;
                if (typeof message !== 'object') {
                    msgToSend = {
                        type: 'text',
                        content: message,
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };
                } else {
                    // 添加发送者ID
                    msgToSend.sender = UserManager.userId;
                    if (!msgToSend.timestamp) {
                        msgToSend.timestamp = new Date().toISOString();
                    }
                }

                conn.dataChannel.send(JSON.stringify(msgToSend));
                return true;
            } catch (error) {
                Utils.log(`发送消息失败: ${error.message}`, Utils.logLevels.ERROR);
                return false;
            }
        },

        // 重置所有连接
        resetAllConnections: function() {
            // 确认对话框
            if (!confirm('确定要重置所有连接吗？这将断开所有现有连接。')) {
                return;
            }

            // 关闭所有连接
            for (const peerId in this.connections) {
                this.close(peerId);
            }

            // 清空连接列表
            this.connections = {};
            this.iceCandidates = {};
            this.connectionTimeouts = {};
            this.reconnectAttempts = {};
            this.iceTimers = {};
            this.iceGatheringStartTimes = {};
            this.connectionStrengths = {};
            this.pendingChunks = {};

            // 重置UI
            UIManager.resetConnectionControls();
            UIManager.updateStatus('所有连接已重置');
            UIManager.enableChatInterface(false);

            // 清空SDP文本
            document.getElementById('sdpText').value = '';

            // 通知用户
            UIManager.showNotification('所有连接已重置', 'info');

            Utils.log('所有连接已重置', Utils.logLevels.INFO);

            return true;
        }
    };

    // UI 管理器
    const UIManager = {
        // 更新连接状态显示
        updateConnectionState: function (connected, state = '') {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.classList.add('connected');
                statusElement.classList.remove('disconnected');

                // 显示返回聊天按钮
                document.querySelector('.sidebar').classList.add('show-back-btn');
            } else {
                if (state === 'disconnected') {
                    statusElement.classList.add('disconnected');
                } else {
                    statusElement.classList.remove('connected');
                }
            }
        },

        // 启用/禁用聊天界面
        enableChatInterface: function(enabled) {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const uploadButton = document.getElementById('uploadButton');
            const voiceButton = document.getElementById('voiceButton');
            const videoCallButton = document.getElementById('videoCallButton');
            const audioCallButton = document.getElementById('audioCallButton'); // 新增
            const clearChatButton = document.getElementById('clearChatButton');

            messageInput.disabled = !enabled;
            sendButton.disabled = !enabled;
            uploadButton.disabled = !enabled;
            voiceButton.disabled = !enabled;
            videoCallButton.disabled = !enabled;
            audioCallButton.disabled = !enabled; // 新增
            clearChatButton.disabled = !enabled;

            if (enabled) {
                // 聚焦输入框
                setTimeout(() => messageInput.focus(), 300);
            }
        },

        // 更新连接状态文本
        updateStatus: function (message, delay = 0) {
            const statusElement = document.getElementById('connectionStatus');

            if (delay > 0) {
                // 如果有延迟，显示倒计时
                statusElement.innerHTML = `${message} <span class="loading-spinner"></span>`;

                let countdown = Math.floor(delay / 1000);
                const timer = setInterval(() => {
                    countdown--;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        statusElement.textContent = message;
                    } else {
                        statusElement.innerHTML = `${message} (${countdown}秒) <span class="loading-spinner"></span>`;
                    }
                }, 1000);
            } else {
                statusElement.textContent = message;
            }
        },

        // 更新连接质量指示器
        updateConnectionQuality: function (rtt) {
            const indicator = document.getElementById('qualityIndicator');
            const qualityText = document.getElementById('qualityText');

            if (!indicator || !qualityText) return;

            try {
                if (rtt < 0.3) {
                    indicator.className = 'quality-indicator quality-good';
                    qualityText.textContent = '良好';
                } else if (rtt < 0.8) {
                    indicator.className = 'quality-indicator quality-medium';
                    qualityText.textContent = '一般';
                } else {
                    indicator.className = 'quality-indicator quality-poor';
                    qualityText.textContent = '较差';
                }
            } catch (error) {
                Utils.log(`更新连接质量显示失败: ${error}`, Utils.logLevels.ERROR);
            }
        },

        // 禁用连接按钮
        disableConnectionButtons: function (stage) {
            switch (stage) {
                case 'offer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = false;
                    break;

                case 'answer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;

                case 'complete':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;
            }
        },

        // 重置连接控件
        resetConnectionControls: function () {
            // 重置连接按钮状态
            document.getElementById('createOfferBtn').disabled = false;
            document.getElementById('createAnswerBtn').disabled = false;
            document.getElementById('handleAnswerBtn').disabled = false;

            // 如果没有活跃连接，隐藏返回聊天按钮
            let hasActiveConnection = false;
            for (const peerId in ConnectionManager.connections) {
                const conn = ConnectionManager.connections[peerId];
                if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    hasActiveConnection = true;
                    break;
                }
            }

            if (!hasActiveConnection) {
                document.querySelector('.sidebar').classList.remove('show-back-btn');
                this.enableChatInterface(false);

                // 移动端：切换回连接设置界面
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }
            }
        },

        // 复制文本
        copyText: function () {
            const textarea = document.getElementById('sdpText');
            textarea.select();
            document.execCommand('copy');

            const copyButton = document.querySelector('.copy-button');
            const originalText = copyButton.textContent;

            copyButton.textContent = '已复制！';
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 2000);
        },

        // 检查WebRTC支持
        checkWebRTCSupport: function () {
            if (typeof RTCPeerConnection === 'undefined') {
                this.updateStatus('您的浏览器不支持 WebRTC，请使用 Chrome 等现代浏览器');
                Utils.log('浏览器不支持WebRTC', Utils.logLevels.ERROR);
                return false;
            }

            if (typeof navigator.mediaDevices === 'undefined' ||
                typeof navigator.mediaDevices.getUserMedia === 'undefined') {
                Utils.log('浏览器可能不完全支持媒体设备API', Utils.logLevels.WARN);
            }

            return true;
        },

        // 显示通知消息
        showNotification: function (message, type = 'info') {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;

            // 设置图标
            let icon = '';
            switch (type) {
                case 'warning':
                    icon = '⚠️';
                    break;
                case 'error':
                    icon = '❌';
                    break;
                case 'success':
                    icon = '✅';
                    break;
                default:
                    icon = 'ℹ️';
            }

            notification.innerHTML = `
                <span class="notification-icon">${icon}</span>
                <span class="notification-message">${message}</span>
                <button class="notification-close">×</button>
            `;

            // 添加到界面
            if (!document.querySelector('.notification-container')) {
                const container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const container = document.querySelector('.notification-container');
            container.appendChild(notification);

            // 点击关闭按钮移除通知
            notification.querySelector('.notification-close').addEventListener('click', () => {
                notification.classList.add('notification-hide');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }

                    // 如果容器为空，移除容器
                    if (container.children.length === 0) {
                        container.parentNode.removeChild(container);
                    }
                }, 300);
            });

            // 自动关闭
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('notification-hide');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }

                        // 如果容器为空，移除容器
                        if (container.children.length === 0) {
                            container.parentNode.removeChild(container);
                        }
                    }, 300);
                }
            }, 10000); // 10秒后自动关闭
        },

        // 显示重连提示
        showReconnectPrompt: function(peerId, onReconnectSuccess) {
            // 创建重连提示元素
            const reconnectPrompt = document.createElement('div');
            reconnectPrompt.className = 'reconnect-prompt';
            reconnectPrompt.innerHTML = `
        <div class="reconnect-message">
            <p>连接未建立，无法发送消息</p>
            <div class="reconnect-buttons">
                <button class="reconnect-btn">重新连接</button>
                <button class="cancel-btn">取消</button>
            </div>
        </div>
    `;

            // 添加到聊天框
            const chatBox = document.getElementById('chatBox');
            chatBox.appendChild(reconnectPrompt);
            chatBox.scrollTop = chatBox.scrollHeight;

            // 设置重连按钮事件
            const reconnectBtn = reconnectPrompt.querySelector('.reconnect-btn');
            reconnectBtn.addEventListener('click', async () => {
                // 移除提示
                if (reconnectPrompt.parentNode) {
                    reconnectPrompt.parentNode.removeChild(reconnectPrompt);
                }

                // 显示连接面板
                document.querySelector('.connection-tab[data-tab="connect"]').click();

                // 如果在移动设备上，切换到连接界面
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }

                // 重置连接按钮状态
                this.resetConnectionControls();

                // 添加系统消息
                const reconnectingMsg = document.createElement('div');
                reconnectingMsg.className = 'system-message';
                reconnectingMsg.textContent = '正在尝试重新连接...';
                chatBox.appendChild(reconnectingMsg);

                // 自动开始连接流程
                try {
                    // 清空之前的连接信息
                    document.getElementById('sdpText').value = '';

                    // 初始化新连接
                    await ConnectionManager.createOffer();

                    // 显示通知
                    this.showNotification('请将连接信息发送给对方，并等待对方回复', 'info');

                    // 监听连接状态变化
                    const checkConnection = () => {
                        if (ConnectionManager.isConnectedTo(peerId)) {
                            // 连接成功
                            const successMsg = document.createElement('div');
                            successMsg.className = 'system-message success';
                            successMsg.textContent = '连接已重新建立';
                            chatBox.appendChild(successMsg);
                            chatBox.scrollTop = chatBox.scrollHeight;

                            // 执行成功回调
                            if (typeof onReconnectSuccess === 'function') {
                                onReconnectSuccess();
                            }

                            // 如果在移动设备上，切换回聊天界面
                            if (window.innerWidth <= 768) {
                                document.querySelector('.container').classList.add('connected-mode');
                            }

                            return true;
                        }
                        return false;
                    };

                    // 定期检查连接状态
                    const checkInterval = setInterval(() => {
                        if (checkConnection()) {
                            clearInterval(checkInterval);
                        }
                    }, 2000);

                    // 60秒后停止检查
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        if (!ConnectionManager.isConnectedTo(peerId)) {
                            const failMsg = document.createElement('div');
                            failMsg.className = 'system-message error';
                            failMsg.textContent = '连接建立失败，请手动完成连接步骤';
                            chatBox.appendChild(failMsg);
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                    }, 60000);

                } catch (error) {
                    Utils.log(`自动重连失败: ${error.message}`, Utils.logLevels.ERROR);
                    this.showNotification('自动重连失败，请手动建立连接', 'error');
                }
            });

            // 设置取消按钮事件
            const cancelBtn = reconnectPrompt.querySelector('.cancel-btn');
            cancelBtn.addEventListener('click', () => {
                if (reconnectPrompt.parentNode) {
                    reconnectPrompt.parentNode.removeChild(reconnectPrompt);
                }
            });

            // 添加样式
            if (!document.getElementById('reconnect-prompt-style')) {
                const style = document.createElement('style');
                style.id = 'reconnect-prompt-style';
                style.textContent = `
            .reconnect-prompt {
                padding: 10px;
                margin: 10px auto;
                max-width: 80%;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                text-align: center;
            }
            .reconnect-message {
                font-size: 14px;
                color: #333;
            }
            .reconnect-buttons {
                margin-top: 10px;
                display: flex;
                justify-content: center;
                gap: 10px;
            }
            .reconnect-btn {
                background: #007bff;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .cancel-btn {
                background: #f44336;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .system-message {
                text-align: center;
                padding: 5px 10px;
                margin: 5px auto;
                font-size: 12px;
                color: #666;
                background: rgba(0,0,0,0.05);
                border-radius: 10px;
                max-width: 80%;
            }
            .system-message.success {
                color: #4CAF50;
            }
            .system-message.error {
                color: #f44336;
            }
        `;
                document.head.appendChild(style);
            }
        }
    };

    // 媒体管理器
    const MediaManager = {
        mediaRecorder: null,
        audioChunks: [],
        recordingTimer: null,
        recordingStartTime: null,
        recordingDuration: 0,

        // 初始化语音录制
        initVoiceRecording: function() {
            // 不再主动请求麦克风权限，而是在按下录音按钮时请求

            // 检查是否在安全上下文(HTTPS)
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                Utils.log('语音录制功能需要HTTPS环境', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = '录音功能需要HTTPS环境';
                voiceButton.innerHTML = '<span id="voiceButtonText">需要HTTPS</span>';

                // 显示提示消息
                UIManager.showNotification('语音录制功能需要HTTPS安全环境才能使用，请使用HTTPS访问本页面。', 'warning');
                return;
            }

            // 检查浏览器是否支持getUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('浏览器不支持录音功能', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = '您的浏览器不支持录音功能';
                voiceButton.innerHTML = '<span id="voiceButtonText">录音不可用</span>';
                return;
            }

            // 启用录音按钮，但延迟请求权限
            document.getElementById('voiceButton').disabled = false;
            Utils.log('语音录制按钮已启用，将在用户点击时请求权限', Utils.logLevels.INFO);
        },

        // 添加一个新方法来请求麦克风权限
        requestMicrophonePermission: async function() {
            if (this.mediaRecorder) {
                return true; // 已经有权限了
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});

                // 尝试使用更好的编码方式
                const options = {};

                // 尝试使用 opus 编码器
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    options.mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    options.mimeType = 'audio/mp4';
                }

                this.mediaRecorder = new MediaRecorder(stream, options);

                this.mediaRecorder.ondataavailable = (event) => {
                    this.audioChunks.push(event.data);
                };

                this.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, {type: options.mimeType || 'audio/webm'});
                    const reader = new FileReader();

                    reader.onloadend = () => {
                        MessageManager.audioData = reader.result;
                        MessageManager.audioDuration = this.recordingDuration;
                        this.displayAudioPreview(reader.result, this.recordingDuration);
                    };

                    reader.readAsDataURL(audioBlob);
                };

                Utils.log('麦克风权限已获取', Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`获取麦克风权限失败: ${error.message}`, Utils.logLevels.ERROR);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                document.getElementById('voiceButtonText').textContent = '录音不可用';

                // 显示友好的错误提示
                UIManager.showNotification('无法访问麦克风，语音录制功能不可用。', 'error');
                return false;
            }
        },

        // 开始录音
        startRecording: async function() {
            // 先请求权限
            if (!this.mediaRecorder) {
                const permissionGranted = await this.requestMicrophonePermission();
                if (!permissionGranted) return;
            }

            try {
                this.audioChunks = [];
                this.mediaRecorder.start();
                this.recordingStartTime = Date.now();

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.add('recording');
                voiceButtonText.textContent = '停止录音';
                voiceTimer.style.display = 'inline';

                this.recordingTimer = setInterval(() => this.updateRecordingTimer(), 1000);
                this.updateRecordingTimer();

                Utils.log('开始录音', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`开始录音失败: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // 停止录音
        stopRecording: function () {
            if (!this.mediaRecorder || this.mediaRecorder.state !== 'recording') return;

            try {
                this.mediaRecorder.stop();
                clearInterval(this.recordingTimer);

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.remove('recording');
                voiceButtonText.textContent = '录音';
                voiceTimer.style.display = 'none';

                Utils.log('录音已停止', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`停止录音失败: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        releaseAudioResources: function() {
            // 检查是否有活跃的媒体流
            if (this.mediaRecorder && this.mediaRecorder.stream) {
                // 停止所有音频轨道
                this.mediaRecorder.stream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log('麦克风资源已释放', Utils.logLevels.DEBUG);
                });
            }

            // 重置录音器
            this.mediaRecorder = null;
        },

        // 更新录音计时器
        updateRecordingTimer: function () {
            const now = Date.now();
            const duration = Math.floor((now - this.recordingStartTime) / 1000);
            this.recordingDuration = duration;

            const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
            const seconds = (duration % 60).toString().padStart(2, '0');
            document.getElementById('voiceTimer').textContent = `${minutes}:${seconds}`;

            // 如果超过最大录制时间，自动停止
            if (duration >= Config.media.maxAudioDuration) {
                this.stopRecording();
            }
        },

        // 处理文件选择方法
        handleFileSelect: async function (event) {
            const file = event.target.files[0];
            if (!file) return;

            // 检查文件大小
            const maxFileSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxFileSize) {
                alert(`文件大小不能超过 ${maxFileSize / 1024 / 1024} MB`);
                return;
            }

            try {
                const reader = new FileReader();

                reader.onload = async (e) => {
                    const fileData = e.target.result;
                    const fileType = file.type;
                    const fileName = file.name;
                    const fileSize = file.size;

                    // 设置消息对象
                    MessageManager.selectedFile = {
                        data: fileData,
                        type: fileType,
                        name: fileName,
                        size: fileSize
                    };

                    // 显示文件预览
                    this.displayFilePreview(MessageManager.selectedFile);
                };

                // 使用readAsDataURL读取为base64格式
                reader.readAsDataURL(file);
            } catch (error) {
                Utils.log(`处理文件失败: ${error.message}`, Utils.logLevels.ERROR);
                alert('处理文件失败');
            }
        },

        // 显示文件预览方法
        displayFilePreview: function (fileObj) {
            const container = document.getElementById('filePreviewContainer');
            const fileType = fileObj.type;
            const fileName = fileObj.name;
            let previewHtml = '';

            // 根据文件类型显示不同预览
            if (fileType.startsWith('image/')) {
                // 图片预览
                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">取消</button>
                    </div>
                    <div class="file-preview-content">
                        <img src="${fileObj.data}" class="image-preview" alt="${fileName}">
                    </div>
                </div>
            `;
            } else if (fileType.startsWith('video/')) {
                // 视频预览
                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">取消</button>
                    </div>
                    <div class="file-preview-content">
                        <video controls class="video-preview">
                            <source src="${fileObj.data}" type="${fileType}">
                            您的浏览器不支持视频预览
                        </video>
                    </div>
                </div>
            `;
            } else {
                // 其他文件类型，显示文件信息
                const fileSize = this.formatFileSize(fileObj.size);
                const fileIcon = this.getFileIcon(fileType);

                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">取消</button>
                    </div>
                    <div class="file-preview-content file-info">
                        <div class="file-icon">${fileIcon}</div>
                        <div class="file-details">
                            <div class="file-name">${fileName}</div>
                            <div class="file-size">${fileSize}</div>
                            <div class="file-type">${fileType || '未知类型'}</div>
                        </div>
                    </div>
                </div>
            `;
            }

            container.innerHTML = previewHtml;
        },

        // 格式化文件大小
        formatFileSize: function(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        },

        // 获取文件图标
        getFileIcon: function(mimeType) {
            if (!mimeType) return '📄';

            if (mimeType.startsWith('image/')) return '🖼️';
            if (mimeType.startsWith('video/')) return '🎬';
            if (mimeType.startsWith('audio/')) return '🎵';

            if (mimeType === 'application/pdf') return '📕';
            if (mimeType.includes('word')) return '📘';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return '📗';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return '📙';

            if (mimeType.includes('zip') || mimeType.includes('compressed')) return '🗜️';
            if (mimeType.includes('text')) return '📝';

            return '📄';
        },

        // 显示音频预览
        displayAudioPreview: function (audioData, duration) {
            const container = document.getElementById('audioPreviewContainer');
            const formattedDuration = Utils.formatTime(duration);

            container.innerHTML = `
            <div class="voice-message">
                <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${audioData}">
                    播放
                </button>
                <div class="voice-wave">
                    ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                </div>
                <span class="duration">${formattedDuration}</span>
                <button onclick="MessageManager.cancelAudioData()">取消</button>
            </div>
            `;

            // 音频数据已保存，可以释放麦克风资源
            this.releaseAudioResources();
        },

        // 播放音频
        playAudio: function (button) {
            const audio = new Audio(button.dataset.audio);
            const originalText = button.textContent;

            button.textContent = '播放中...';
            audio.play();

            // 添加波形动画效果
            const waveContainer = button.nextElementSibling;
            if (waveContainer && waveContainer.classList.contains('voice-wave')) {
                waveContainer.classList.add('playing');
            }

            audio.onended = () => {
                button.textContent = originalText;
                if (waveContainer) {
                    waveContainer.classList.remove('playing');
                }
            };

            audio.onerror = () => {
                button.textContent = '播放失败';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            };
        }
    };

    // 视频通话管理器
    const VideoCallManager = {
        localStream: null,
        remoteStream: null,
        localVideo: null,
        remoteVideo: null,
        currentPeerId: null,
        isCallActive: false,
        isCaller: false,
        isCallPending: false,
        isAudioMuted: false,
        isVideoEnabled: true,
        callRequestTimeout: null,

        // 初始化
        // 初始化
        init: function() {
            this.localVideo = document.getElementById('localVideo');
            this.remoteVideo = document.getElementById('remoteVideo');

            // 检查浏览器支持
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('浏览器不支持音视频通话功能', Utils.logLevels.ERROR);
                document.getElementById('videoCallButton').disabled = true;
                document.getElementById('videoCallButton').title = '您的浏览器不支持音视频通话';
                return false;
            }

            // 监听视频通话消息
            EventEmitter.on('dataChannelOpen', (peerId) => {
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => this.initiateCall(peerId);
                }
            });

            return true;
        },

        // 发起通话
        // 发起通话
        initiateCall: async function(peerId, audioOnly = false) {
            if (this.isCallActive || this.isCallPending) return;

            // 如果没有指定peerId，使用当前聊天对象
            if (!peerId) {
                peerId = ChatManager.currentChatId;
            }

            if (!peerId) {
                UIManager.showNotification('请先选择聊天对象', 'warning');
                return;
            }

            if (!ConnectionManager.isConnectedTo(peerId)) {
                UIManager.showNotification('连接未建立，无法发起通话', 'error');
                return;
            }

            try {
                // 检查设备支持情况
                if (!audioOnly) {
                    // 检查视频设备是否可用
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('未检测到摄像头设备，将使用语音通话模式', 'warning');
                        audioOnly = true;
                    } else {
                        // 尝试获取视频权限
                        try {
                            const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                            // 成功获取后立即释放
                            testStream.getTracks().forEach(track => track.stop());
                        } catch (error) {
                            UIManager.showNotification('无法访问摄像头，将使用语音通话模式', 'warning');
                            Utils.log(`视频权限检查失败: ${error.message}`, Utils.logLevels.WARN);
                            audioOnly = true;
                        }
                    }
                }

                // 检查音频设备
                try {
                    const testAudioStream = await navigator.mediaDevices.getUserMedia({audio: true});
                    // 成功获取后立即释放
                    testAudioStream.getTracks().forEach(track => track.stop());
                } catch (error) {
                    UIManager.showNotification('无法访问麦克风，通话功能不可用', 'error');
                    Utils.log(`音频权限检查失败: ${error.message}`, Utils.logLevels.ERROR);
                    return;
                }

                this.currentPeerId = peerId;
                this.isCaller = true;
                this.isCallPending = true;
                this.isAudioOnly = audioOnly;

                // 告知对方请求通话
                const callRequest = {
                    type: 'video-call-request',
                    audioOnly: audioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };

                ConnectionManager.sendTo(peerId, callRequest);

                UIManager.showNotification(`等待对方接受${audioOnly ? '语音' : '视频'}通话...`, 'info');
                Utils.log(`已发送${audioOnly ? '语音' : '视频'}通话请求`, Utils.logLevels.INFO);

                // 30秒超时
                this.callRequestTimeout = setTimeout(() => {
                    if (this.isCallPending) {
                        this.isCallPending = false;
                        this.isCaller = false;
                        this.currentPeerId = null;
                        UIManager.showNotification('对方未应答，通话请求已取消', 'warning');

                        // 发送取消消息
                        const cancelRequest = {
                            type: 'video-call-cancel',
                            timestamp: Date.now(),
                            sender: UserManager.userId
                        };
                        ConnectionManager.sendTo(peerId, cancelRequest);
                    }
                }, 30000);
            } catch (error) {
                Utils.log(`发起通话失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('发起通话失败', 'error');
                this.isCallPending = false;
                this.isCaller = false;
                this.currentPeerId = null;
            }
        },

        // 显示通话请求
        showCallRequest: function(peerId, audioOnly = false) {
            this.currentPeerId = peerId;
            this.isAudioOnly = audioOnly;

            // 修改通话请求界面，显示是语音还是视频通话请求
            const requestTitle = document.querySelector('#videoCallRequest h3');
            const requestDesc = document.querySelector('#videoCallRequest p');
            if (requestTitle && requestDesc) {
                requestTitle.textContent = audioOnly ? '语音通话请求' : '视频通话请求';
                requestDesc.textContent = `对方请求与您进行${audioOnly ? '语音' : '视频'}通话`;
            }

            document.getElementById('videoCallRequest').style.display = 'flex';
        },

        // 隐藏通话请求
        hideCallRequest: function() {
            document.getElementById('videoCallRequest').style.display = 'none';
        },

        // 接受通话
        acceptCall: async function() {
            this.hideCallRequest();

            if (!this.currentPeerId) {
                UIManager.showNotification('通话请求无效', 'error');
                return;
            }

            try {
                // 显示获取媒体设备权限的提示
                UIManager.showNotification('正在请求媒体设备权限...', 'info');

                // 检查设备支持情况
                if (!this.isAudioOnly) {
                    // 检查视频设备是否可用
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('未检测到摄像头设备，将使用语音通话模式', 'warning');
                        this.isAudioOnly = true;
                    } else {
                        // 尝试获取视频权限
                        try {
                            const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                            // 成功获取后立即释放
                            testStream.getTracks().forEach(track => track.stop());
                        } catch (error) {
                            UIManager.showNotification('无法访问摄像头，将使用语音通话模式', 'warning');
                            Utils.log(`视频权限检查失败: ${error.message}`, Utils.logLevels.WARN);
                            this.isAudioOnly = true;
                        }
                    }
                }

                // 获取媒体权限
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: !this.isAudioOnly,
                    audio: true
                });

                // 显示本地视频（如果是视频通话）
                this.localVideo.srcObject = this.localStream;

                // 如果是纯语音通话，隐藏本地视频区域
                this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';

                // 设置音频专用按钮状态
                const audioOnlyBtn = document.getElementById('audioOnlyBtn');
                if (audioOnlyBtn) {
                    audioOnlyBtn.style.background = this.isAudioOnly ? '#4CAF50' : '#fff';
                    audioOnlyBtn.title = this.isAudioOnly ? '切换到视频通话' : '切换到纯语音通话';
                }

                // 使用现有的连接
                this.setupPeerConnection();

                // 显示视频通话界面
                document.getElementById('videoCallContainer').style.display = 'flex';

                // 发送接受信号
                const acceptMessage = {
                    type: 'video-call-accepted',
                    audioOnly: this.isAudioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, acceptMessage);

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log(`已接受${this.isAudioOnly ? '语音' : '视频'}通话`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`接受通话失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('无法访问媒体设备', 'error');

                // 发送拒绝消息，标明原因是设备问题
                const rejectMessage = {
                    type: 'video-call-rejected',
                    reason: 'device_error',
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, rejectMessage);

                this.currentPeerId = null;
            }
        },

        // 拒绝通话
        rejectCall: function() {
            this.hideCallRequest();

            if (!this.currentPeerId) return;

            // 发送拒绝消息
            const rejectMessage = {
                type: 'video-call-rejected',
                reason: 'user_rejected',
                timestamp: Date.now(),
                sender: UserManager.userId
            };
            ConnectionManager.sendTo(this.currentPeerId, rejectMessage);

            // 重置状态
            this.isCallPending = false;
            this.isCallActive = false;
            this.isCaller = false;
            this.currentPeerId = null;
            this.isAudioOnly = false;

            Utils.log('已拒绝通话请求', Utils.logLevels.INFO);
        },

        // 设置对等连接
        setupPeerConnection: function() {
            // 使用已有的连接传递信令
            if (!this.currentPeerId || !ConnectionManager.connections[this.currentPeerId]) {
                Utils.log('无法创建通话连接: 没有基础连接', Utils.logLevels.ERROR);
                return;
            }

            const conn = ConnectionManager.connections[this.currentPeerId];

            // 添加本地流
            this.localStream.getTracks().forEach(track => {
                conn.peerConnection.addTrack(track, this.localStream);
            });

            // 处理远程流
            conn.peerConnection.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    this.remoteVideo.srcObject = event.streams[0];
                    this.remoteStream = event.streams[0];

                    // 检查是否有视频轨道，如果只有音频则隐藏远程视频
                    const hasVideoTrack = event.streams[0].getVideoTracks().length > 0;
                    this.remoteVideo.style.display = hasVideoTrack ? 'block' : 'none';

                    Utils.log(`收到远程${hasVideoTrack ? '视频' : '音频'}流`, Utils.logLevels.INFO);
                }
            };

            // 如果是呼叫方，创建并发送offer
            if (this.isCaller) {
                this.createAndSendOffer();
            }
        },

        // 创建并发送offer
        createAndSendOffer: async function() {
            try {
                if (!this.currentPeerId) return;

                const conn = ConnectionManager.connections[this.currentPeerId];
                if (!conn || !conn.peerConnection) return;

                const offer = await conn.peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: !this.isAudioOnly
                });

                await conn.peerConnection.setLocalDescription(offer);

                // 发送offer给对方
                const offerMessage = {
                    type: 'video-call-offer',
                    sdp: conn.peerConnection.localDescription,
                    audioOnly: this.isAudioOnly,
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, offerMessage);

                Utils.log(`已发送${this.isAudioOnly ? '语音' : '视频'}通话offer`, Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`创建offer失败: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // 处理收到的offer
        handleOffer: async function(offer, peerId, audioOnly) {
            try {
                this.currentPeerId = peerId;
                this.isAudioOnly = audioOnly;

                const conn = ConnectionManager.connections[peerId];
                if (!conn || !conn.peerConnection) return;

                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // 创建answer
                const answer = await conn.peerConnection.createAnswer();
                await conn.peerConnection.setLocalDescription(answer);

                // 发送answer给对方
                const answerMessage = {
                    type: 'video-call-answer',
                    sdp: conn.peerConnection.localDescription,
                    audioOnly: this.isAudioOnly,
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(peerId, answerMessage);

                Utils.log(`已回复${this.isAudioOnly ? '语音' : '视频'}通话answer`, Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`处理offer失败: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // 处理收到的answer
        handleAnswer: async function(answer, peerId, audioOnly) {
            try {
                if (this.currentPeerId !== peerId) return;

                // 更新通话类型
                this.isAudioOnly = audioOnly;

                // 更新UI显示
                this.updateUIForCallType();

                const conn = ConnectionManager.connections[peerId];
                if (!conn || !conn.peerConnection) return;

                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                Utils.log('已设置远程描述', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`处理answer失败: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // 切换摄像头
        toggleCamera: function() {
            if (!this.localStream) return;

            // 如果是纯语音模式，切换到视频模式
            if (this.isAudioOnly) {
                this.toggleAudioOnly();
                return;
            }

            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                this.isVideoEnabled = !this.isVideoEnabled;
                videoTrack.enabled = this.isVideoEnabled;

                const button = document.getElementById('toggleCameraBtn');
                button.innerHTML = this.isVideoEnabled ? '📹' : '🚫';
                button.style.background = this.isVideoEnabled ? '#fff' : '#666';

                Utils.log(`摄像头已${this.isVideoEnabled ? '开启' : '关闭'}`, Utils.logLevels.DEBUG);
            } else {
                // 没有视频轨道，可能是设备不支持或权限问题
                UIManager.showNotification('无法访问摄像头', 'warning');
            }
        },

        // 切换麦克风
        toggleAudio: function() {
            if (!this.localStream) return;

            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                this.isAudioMuted = !this.isAudioMuted;
                audioTrack.enabled = !this.isAudioMuted;

                const button = document.getElementById('toggleAudioBtn');
                button.innerHTML = this.isAudioMuted ? '🔇' : '🎤';
                button.style.background = this.isAudioMuted ? '#666' : '#fff';

                Utils.log(`麦克风已${this.isAudioMuted ? '静音' : '开启'}`, Utils.logLevels.DEBUG);
            }
        },

        // 切换纯语音模式
        // 切换纯语音模式
        toggleAudioOnly: async function() {
            if (!this.isCallActive) return;

            try {
                // 如果要切换到视频模式，先检查是否支持视频
                if (this.isAudioOnly) {
                    // 检查视频设备是否可用
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('未检测到摄像头设备，无法切换到视频模式', 'warning');
                        return;
                    }

                    // 尝试获取视频权限
                    try {
                        const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                        // 成功获取后立即释放
                        testStream.getTracks().forEach(track => track.stop());
                    } catch (error) {
                        UIManager.showNotification('无法访问摄像头，无法切换到视频模式', 'error');
                        Utils.log(`视频权限检查失败: ${error.message}`, Utils.logLevels.ERROR);
                        return;
                    }
                }

                this.isAudioOnly = !this.isAudioOnly;

                // 更新UI
                this.updateUIForCallType();

                // 停止当前媒体流
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }

                // 重新获取媒体权限
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: !this.isAudioOnly,
                    audio: true
                });

                // 更新本地视频
                this.localVideo.srcObject = this.localStream;

                const conn = ConnectionManager.connections[this.currentPeerId];
                if (!conn || !conn.peerConnection) return;

                // 替换所有轨道
                const senders = conn.peerConnection.getSenders();
                const tracks = this.localStream.getTracks();

                // 查找已有的音频和视频发送器
                const audioSender = senders.find(s => s.track && s.track.kind === 'audio');
                const videoSender = senders.find(s => s.track && s.track.kind === 'video');

                // 获取新的音频和视频轨道
                const audioTrack = tracks.find(t => t.kind === 'audio');
                const videoTrack = tracks.find(t => t.kind === 'video');

                // 替换音频轨道
                if (audioSender && audioTrack) {
                    audioSender.replaceTrack(audioTrack);
                } else if (audioTrack) {
                    conn.peerConnection.addTrack(audioTrack, this.localStream);
                }

                // 处理视频轨道
                if (this.isAudioOnly) {
                    // 在纯语音模式下，如果有视频发送器，将其移除
                    if (videoSender) {
                        try {
                            conn.peerConnection.removeTrack(videoSender);
                        } catch (e) {
                            Utils.log(`移除视频轨道失败: ${e.message}`, Utils.logLevels.ERROR);
                        }
                    }
                } else {
                    // 在视频模式下，替换或添加视频轨道
                    if (videoSender && videoTrack) {
                        videoSender.replaceTrack(videoTrack);
                    } else if (videoTrack) {
                        conn.peerConnection.addTrack(videoTrack, this.localStream);
                    }
                }

                // 通知对方模式已更改
                const modeChangeMsg = {
                    type: 'video-call-mode-change',
                    audioOnly: this.isAudioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, modeChangeMsg);

                Utils.log(`已切换到${this.isAudioOnly ? '纯语音' : '视频'}通话模式`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`切换通话模式失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('切换通话模式失败', 'error');
            }
        },

        // 更新UI以匹配当前通话类型
        updateUIForCallType: function() {
            // 设置本地视频显示
            if (this.localVideo) {
                this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';
            }

            // 更新音频模式按钮
            const audioOnlyBtn = document.getElementById('audioOnlyBtn');
            if (audioOnlyBtn) {
                audioOnlyBtn.style.background = this.isAudioOnly ? '#4CAF50' : '#fff';
                audioOnlyBtn.title = this.isAudioOnly ? '切换到视频通话' : '切换到纯语音通话';
            }

            // 更新摄像头按钮状态
            const cameraBtn = document.getElementById('toggleCameraBtn');
            if (cameraBtn) {
                cameraBtn.style.display = this.isAudioOnly ? 'none' : 'inline-block';
            }

            // 调整视频容器的布局
            const videoContainer = document.getElementById('videoCallContainer');
            if (videoContainer) {
                videoContainer.classList.toggle('audio-only-mode', this.isAudioOnly);
            }
        },

        // 结束通话
        endCall: function() {
            // 清除超时定时器
            if (this.callRequestTimeout) {
                clearTimeout(this.callRequestTimeout);
                this.callRequestTimeout = null;
            }

            // 发送结束通话信号
            if ((this.isCallActive || this.isCallPending) && this.currentPeerId) {
                const endCallMessage = {
                    type: 'video-call-end',
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                try {
                    ConnectionManager.sendTo(this.currentPeerId, endCallMessage);
                } catch (error) {
                    Utils.log(`发送结束通话消息失败: ${error.message}`, Utils.logLevels.ERROR);
                }
            }

            // 彻底关闭并停止所有媒体轨道
            this.releaseMediaResources();

            // 重置视频元素
            if (this.localVideo) this.localVideo.srcObject = null;
            if (this.remoteVideo) this.remoteVideo.srcObject = null;
            this.remoteStream = null;

            // 隐藏视频通话界面
            document.getElementById('videoCallContainer').style.display = 'none';
            this.hideCallRequest();

            // 重置状态
            this.isCallActive = false;
            this.isCallPending = false;
            this.isCaller = false;
            this.isAudioMuted = false;
            this.isVideoEnabled = true;
            this.isAudioOnly = false;
            this.currentPeerId = null;

            // 重置连接按钮状态
            UIManager.resetConnectionControls();

            Utils.log('通话已结束，所有资源已释放', Utils.logLevels.INFO);
        },

        // 添加一个新方法专门负责释放媒体资源
        releaseMediaResources: function() {
            // 关闭本地视频/音频轨道
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log(`已停止${track.kind}轨道`, Utils.logLevels.DEBUG);
                });
                this.localStream = null;
            }

            // 如果有远程流，也可以考虑清理
            if (this.remoteStream) {
                // 我们不需要停止远程轨道，但可以清除引用
                this.remoteStream = null;
            }
        },

        // 处理消息
        handleMessage: function(message, peerId) {
            switch (message.type) {
                case 'video-call-request':
                    if (!this.isCallActive && !this.isCallPending) {
                        this.isCallPending = true;
                        // 注意新增的audioOnly参数
                        this.showCallRequest(peerId, message.audioOnly || false);
                        Utils.log(`收到${message.audioOnly ? '语音' : '视频'}通话请求`, Utils.logLevels.INFO);
                    } else {
                        // 已在通话中，自动拒绝
                        const busyMessage = {
                            type: 'video-call-rejected',
                            reason: 'busy',
                            timestamp: Date.now(),
                            sender: UserManager.userId
                        };
                        ConnectionManager.sendTo(peerId, busyMessage);
                    }
                    break;

                case 'video-call-accepted':
                    if (this.isCallPending && this.isCaller && this.currentPeerId === peerId) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;

                        // 更新通话类型（接收方可能改变了通话类型）
                        if (typeof message.audioOnly !== 'undefined') {
                            this.isAudioOnly = message.audioOnly;
                        }

                        // 对方已接受，开始通话
                        this.startLocalStream();
                    }
                    break;

                case 'video-call-rejected':
                    if (this.isCallPending && this.currentPeerId === peerId) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;
                        this.isCallPending = false;
                        this.isCaller = false;
                        this.currentPeerId = null;
                        this.isAudioOnly = false;

                        // 释放已申请的任何媒体资源
                        this.releaseMediaResources();

                        let reason = '对方拒绝了通话';
                        if (message.reason === 'busy') {
                            reason = '对方正忙';
                        } else if (message.reason === 'device_error') {
                            reason = '对方无法访问麦克风或摄像头';
                        }

                        UIManager.showNotification(reason, 'warning');
                        Utils.log(`通话被拒绝: ${message.reason}`, Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-cancel':
                    if (this.isCallPending && !this.isCaller && this.currentPeerId === peerId) {
                        this.isCallPending = false;
                        this.hideCallRequest();
                        this.currentPeerId = null;
                        this.isAudioOnly = false;

                        // 释放已申请的任何媒体资源
                        this.releaseMediaResources();

                        Utils.log('对方取消了通话请求', Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-offer':
                    if (this.isCallActive && !this.isCaller && this.currentPeerId === peerId) {
                        // 注意新增的audioOnly参数
                        this.handleOffer(message.sdp, peerId, message.audioOnly || false);
                    }
                    break;

                case 'video-call-answer':
                    if (this.isCallActive && this.isCaller && this.currentPeerId === peerId) {
                        // 注意新增的audioOnly参数
                        this.handleAnswer(message.sdp, peerId, message.audioOnly || false);
                    }
                    break;

                case 'video-call-mode-change':
                    if (this.isCallActive && this.currentPeerId === peerId) {
                        // 对方更改了通话模式
                        this.isAudioOnly = message.audioOnly;
                        this.updateUIForCallType();
                        Utils.log(`对方已切换到${this.isAudioOnly ? '纯语音' : '视频'}通话模式`, Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-end':
                    if ((this.isCallActive || this.isCallPending) && this.currentPeerId === peerId) {
                        this.endCall();
                        UIManager.showNotification('对方结束了通话', 'info');
                    }
                    break;
            }
        },

        // 开始本地流
        startLocalStream: async function() {
            try {
                // 只有在还没有本地流时才请求权限
                if (!this.localStream) {
                    // 显示获取媒体设备权限的提示
                    UIManager.showNotification('正在请求媒体设备权限...', 'info');

                    // 获取权限
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: !this.isAudioOnly,
                        audio: true
                    });

                    // 显示本地视频（如果不是纯语音通话）
                    this.localVideo.srcObject = this.localStream;
                    this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';
                }

                // 创建WebRTC连接
                this.setupPeerConnection();

                // 显示视频通话界面
                document.getElementById('videoCallContainer').style.display = 'flex';

                // 更新UI以匹配当前通话类型
                this.updateUIForCallType();

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log(`${this.isAudioOnly ? '语音' : '视频'}通话已开始`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`启动通话失败: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('无法访问媒体设备', 'error');
                this.endCall();
            }
        },

        // 初始化语音通话
        initiateAudioCall: function(peerId) {
            // 调用通用的initiateCall方法，设置audioOnly为true
            this.initiateCall(peerId, true);
        },
    };

    // 消息管理器
    const MessageManager = {
        selectedFile: null,
        audioData: null,
        audioDuration: 0,

        // 发送消息
        sendMessage: function() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            // 检查是否有选择的聊天
            if (!ChatManager.currentChatId) {
                UIManager.showNotification('请先选择聊天对象', 'warning');
                return;
            }

            // 检查是否是群聊
            const isGroupChat = ChatManager.currentChatId.startsWith('group_');

            // 如果是群聊，检查群组是否存在
            if (isGroupChat && !GroupManager.groups[ChatManager.currentChatId]) {
                UIManager.showNotification('群聊不存在或您已被移出', 'error');
                return;
            }

            // 如果是私聊，检查连接状态
            if (!isGroupChat) {
                const isConnected = ConnectionManager.isConnectedTo(ChatManager.currentChatId);

                if (!isConnected && (message || this.selectedFile || this.audioData)) {
                    // 连接未建立，显示重连提示
                    UIManager.showReconnectPrompt(ChatManager.currentChatId, () => {
                        // 重连成功后的回调，重新尝试发送消息
                        this.sendMessage();
                    });
                    return;
                }
            }

            if (!message && !this.selectedFile && !this.audioData) {
                return;
            }

            // 发送语音消息
            if (this.audioData) {
                const audioMessage = {
                    type: 'audio',
                    data: this.audioData,
                    duration: this.audioDuration,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // 发送到群组
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, audioMessage);
                } else {
                    // 发送到个人
                    Utils.sendInChunks(JSON.stringify(audioMessage),
                        (data) => ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(data));
                }

                // 添加到聊天记录
                ChatManager.addMessage(ChatManager.currentChatId, audioMessage);

                // 更新最后消息
                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, '[语音]');
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, '[语音]');
                }

                this.cancelAudioData();
            }

            // 发送文件消息
            if (this.selectedFile) {
                // 生成唯一文件ID
                const fileId = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;

                const fileMessage = {
                    type: 'file',  // 统一使用file类型
                    fileId: fileId,
                    fileName: this.selectedFile.name,
                    fileType: this.selectedFile.type,
                    fileSize: this.selectedFile.size,
                    data: this.selectedFile.data,  // 这里包含文件的base64数据
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // 发送到群组
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, fileMessage);
                } else {
                    // 发送到个人
                    Utils.sendInChunks(JSON.stringify(fileMessage),
                        (data) => ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(data));
                }

                // 添加到聊天记录
                ChatManager.addMessage(ChatManager.currentChatId, fileMessage);

                // 更新最后消息
                let filePreview = '[文件]';
                if (this.selectedFile.type.startsWith('image/')) filePreview = '[图片]';
                if (this.selectedFile.type.startsWith('video/')) filePreview = '[视频]';
                if (this.selectedFile.type.startsWith('audio/')) filePreview = '[音频]';

                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, filePreview);
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, filePreview);
                }

                this.cancelFileData();
            }

            // 发送文本消息
            if (message) {
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const messageObj = {
                    type: 'text',
                    content: message,
                    links: message.match(urlRegex) || [],
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // 发送到群组
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, messageObj);
                } else {
                    // 发送到个人
                    ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(JSON.stringify(messageObj));
                }

                // 添加到聊天记录
                ChatManager.addMessage(ChatManager.currentChatId, messageObj);

                // 更新最后消息
                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, message);
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, message);
                }

                input.value = '';
            }
        },

        // 清空聊天记录
        clearChat: function() {
            if (!ChatManager.currentChatId) {
                UIManager.showNotification('请先选择聊天对象', 'warning');
                return;
            }

            // 显示确认对话框
            if (confirm('确定要清空聊天记录吗？此操作不可撤销。')) {
                // 清空聊天
                if (ChatManager.clearChat(ChatManager.currentChatId)) {
                    // 添加系统消息提示
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = '已清空聊天记录';
                    systemMessage.style.textAlign = 'center';
                    systemMessage.style.padding = '10px';
                    systemMessage.style.color = '#666';
                    systemMessage.style.fontSize = '12px';
                    document.getElementById('chatBox').appendChild(systemMessage);

                    // 通知用户
                    UIManager.showNotification('聊天记录已清空', 'info');

                    Utils.log('聊天记录已清空', Utils.logLevels.INFO);
                }
            }
        },

        // 显示消息
        displayMessage: function (message, isSent) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;

            if (typeof message === 'string') {
                // 处理纯文本消息，将换行符转换为<br>标签
                messageDiv.innerHTML = this.formatMessageText(message);
            } else {
                switch (message.type) {
                    case 'audio':
                        const audioDiv = document.createElement('div');
                        audioDiv.className = 'voice-message';

                        // 格式化音频持续时间
                        const formattedDuration = typeof message.duration === 'number'
                            ? Utils.formatTime(message.duration)
                            : message.duration;

                        audioDiv.innerHTML = `
                <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${message.data}">
                    播放
                </button>
                <div class="voice-wave">
                    ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                </div>
                <span class="duration">${formattedDuration}</span>
            `;
                        messageDiv.appendChild(audioDiv);
                        break;

                    case 'file':
                        // 处理文件消息
                        const fileDiv = document.createElement('div');
                        fileDiv.className = 'file-message';

                        // 检查是否有文件数据
                        const fileData = message.data || '';

                        // 根据文件类型决定展示方式
                        if (message.fileType && message.fileType.startsWith('image/')) {
                            // 图片
                            fileDiv.innerHTML = `
                        ${fileData ? `<img src="${fileData}" class="file-preview-img" alt="${message.fileName}"
                             onclick="MessageManager.showFullImage('${fileData}')">` : '<div class="file-error">图片数据丢失</div>'}
                    `;
                        } else if (message.fileType && message.fileType.startsWith('video/')) {
                            // 视频
                            fileDiv.innerHTML = `
                        ${fileData ? `<video controls class="file-preview-video">
                            <source src="${fileData}" type="${message.fileType}">
                            您的浏览器不支持视频预览
                        </video>` : '<div class="file-error">视频数据丢失</div>'}
                    `;
                        } else {
                            // 其他文件类型
                            const fileSize = MediaManager.formatFileSize(message.fileSize || 0);
                            const fileIcon = MediaManager.getFileIcon(message.fileType);

                            fileDiv.innerHTML = `
                        <div class="file-info">
                            <div class="file-icon">${fileIcon}</div>
                            <div class="file-details">
                                <div class="file-name">${message.fileName || '未知文件'}</div>
                                <div class="file-meta">
                                    <span class="file-size">${fileSize}</span>
                                    <span class="file-type">${message.fileType || '未知类型'}</span>
                                </div>
                            </div>
                            ${fileData ? `<a href="${fileData}" download="${message.fileName}" class="download-btn">下载</a>` :
                                '<span class="download-error">下载失败</span>'}
                        </div>
                    `;
                        }

                        messageDiv.appendChild(fileDiv);
                        break;

                    // 兼容旧版本的image类型，将其视为file类型处理
                    case 'image':
                        const imgDiv = document.createElement('div');
                        imgDiv.className = 'file-message';

                        // 检查是否有文件数据
                        const imgData = message.data || '';

                        imgDiv.innerHTML = `
                    ${imgData ? `<img src="${imgData}" class="file-preview-img" alt="${message.fileName || '图片'}"
                         onclick="MessageManager.showFullImage('${imgData}')">` : '<div class="file-error">图片数据丢失</div>'}
                `;

                        messageDiv.appendChild(imgDiv);
                        break;

                    case 'text':
                        const textDiv = document.createElement('div');
                        // 使用formatMessageText方法处理文本内容，保留换行符
                        textDiv.innerHTML = this.formatMessageText(message.content);
                        messageDiv.appendChild(textDiv);

                        if (message.links && message.links.length > 0) {
                            message.links.forEach(async (link) => {
                                const linkPreview = await this.createLinkPreview(link);
                                messageDiv.appendChild(linkPreview);
                            });
                        }
                        break;

                    case 'system':
                        // 处理系统消息
                        const systemDiv = document.createElement('div');
                        systemDiv.className = 'system-message';
                        systemDiv.innerHTML = this.formatMessageText(message.content);
                        messageDiv.className = 'message system'; // 覆盖原来的sent/received类名
                        messageDiv.appendChild(systemDiv);
                        break;

                    default:
                        // 未知类型消息
                        messageDiv.textContent = JSON.stringify(message);

                }
            }

            // 添加时间戳和发送者名称
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';

            // 检查是否是群聊消息
            const isGroupChat = ChatManager.currentChatId && ChatManager.currentChatId.startsWith('group_');

            if (isGroupChat && !isSent) {
                const group = GroupManager.groups[ChatManager.currentChatId];

                // 优先使用原始发送者信息
                const senderId = message.originalSender || message.sender;

                // 获取发送者昵称
                let senderName = message.originalSenderName || message.senderName || '未知用户';

                // 如果在联系人列表中有该用户，使用联系人名称
                if (UserManager.contacts[senderId]) {
                    senderName = UserManager.contacts[senderId].name;
                }

                // 检查发送者是否是群主
                if (group && senderId === group.owner) {
                    timestamp.textContent = `${senderName}(群主) · ${message.timestamp ?
                        new Date(message.timestamp).toLocaleTimeString() :
                        new Date().toLocaleTimeString()}`;
                } else {
                    timestamp.textContent = `${senderName} · ${message.timestamp ?
                        new Date(message.timestamp).toLocaleTimeString() :
                        new Date().toLocaleTimeString()}`;
                }

                // 添加转发标识（如果有转发者且不是原始发送者）
                if (message.sender !== message.originalSender && message.sender) {
                    const relayInfo = document.createElement('div');
                    relayInfo.className = 'relay-info';

                    // 获取转发者名称
                    let relayerName = '未知用户';
                    if (UserManager.contacts[message.sender]) {
                        relayerName = UserManager.contacts[message.sender].name;
                    } else if (message.sender === group.owner) {
                        relayerName = '群主';
                    }

                    relayInfo.textContent = `由 ${relayerName} 转发`;
                    timestamp.appendChild(relayInfo);
                }
            } else {
                // 私聊消息或自己发送的消息，只显示时间
                timestamp.textContent = message.timestamp ?
                    new Date(message.timestamp).toLocaleTimeString() :
                    new Date().toLocaleTimeString();
            }

            messageDiv.appendChild(timestamp);

            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        },

        // 显示全屏图片
        showFullImage: function(src) {
            const modal = document.createElement('div');
            modal.style = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; align-items: center;
            justify-content: center; z-index: 1000; cursor: pointer;
        `;

            const fullImg = document.createElement('img');
            fullImg.src = src;
            fullImg.style = 'max-width: 90%; max-height: 90%; object-fit: contain;';

            modal.appendChild(fullImg);
            document.body.appendChild(modal);

            modal.onclick = () => document.body.removeChild(modal);
        },

        formatMessageText: function(text) {
            if (!text) return '';

            // 转义HTML特殊字符，防止XSS攻击
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // 将换行符转换为<br>标签
            return escaped.replace(/\n/g, '<br>');
        },

        // 链接预览
        createLinkPreview: async function (url) {
            const preview = document.createElement('div');
            preview.className = 'link-preview';
            preview.innerHTML = `
            <div class="link-preview-loading">
                <span class="loading-spinner"></span> 加载预览中...
            </div>
        `;

            try {
                const previewData = await this.fetchLinkPreview(url);

                if (previewData) {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        ${previewData.image ?
                        `<img src="${previewData.image}"
                                class="link-preview-image"
                                onerror="this.style.display='none'"
                                alt="${previewData.title || '链接预览'}">`
                        : ''}
                        <div class="link-preview-title">${previewData.title || url}</div>
                        <div class="link-preview-description">${previewData.description || '无描述'}</div>
                        <div class="link-preview-domain">
                            <img src="https://www.google.com/s2/favicons?domain=${previewData.domain}"
                                width="16" height="16" onerror="this.style.display='none'" alt="">
                            ${previewData.domain}
                        </div>
                    </div>
                `;
                } else {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        <div class="link-preview-title">${url}</div>
                        <div class="preview-error">无法加载预览</div>
                    </div>
                `;
                }
            } catch (error) {
                preview.innerHTML = `
                <div class="link-preview-content">
                    <div class="link-preview-title">${url}</div>
                    <div class="preview-error">预览加载失败</div>
                </div>
            `;
            }

            preview.onclick = () => window.open(url, '_blank');
            return preview;
        },

        // 获取链接预览
        fetchLinkPreview: async function (url) {
            try {
                // 使用第三方API获取链接预览（考虑中国网络情况，可能需要替换为国内可用的服务）
                // 在生产环境应使用自己的后端服务来代理请求，避免API服务的限制
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const response = await fetch(`${proxyUrl}${encodeURIComponent(url)}`, {
                    method: 'GET',
                    headers: {'Content-Type': 'text/html'},
                    mode: 'cors',
                    cache: 'force-cache'
                });

                if (!response.ok) throw new Error('无法获取链接内容');

                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // 提取Open Graph数据
                const getMetaContent = (name) => {
                    const element = doc.querySelector(`meta[property="og:${name}"], meta[name="${name}"], meta[name="og:${name}"]`);
                    return element ? element.getAttribute('content') : null;
                };

                const title = getMetaContent('title') || doc.title || '';
                const description = getMetaContent('description') || '';
                const image = getMetaContent('image') || '';
                const domain = new URL(url).hostname;

                return {title, description, image, domain};
            } catch (error) {
                Utils.log(`链接预览获取失败: ${error.message}`, Utils.logLevels.ERROR);

                // 返回基本信息
                try {
                    const domain = new URL(url).hostname;
                    return {
                        title: url,
                        description: '',
                        image: null,
                        domain: domain
                    };
                } catch (e) {
                    return null;
                }
            }
        },

        // 取消文件数据
        cancelFileData: function () {
            this.selectedFile = null;
            document.getElementById('filePreviewContainer').innerHTML = '';
            document.getElementById('fileInput').value = '';
        },

        // 取消音频数据
        cancelAudioData: function () {
            this.audioData = null;
            this.audioDuration = 0;
            document.getElementById('audioPreviewContainer').innerHTML = '';

            // 确保释放媒体资源
            MediaManager.releaseAudioResources();
        }
    };

    // 聊天管理器
    const ChatManager = {
        currentChatId: null,
        chats: {},

        init: async function() {
            // 初始化联系人列表
            await this.loadChats();

            // 设置新建聊天按钮事件
            document.getElementById('newChatBtn').addEventListener('click', () => {
                document.getElementById('newChatForm').style.display = 'block';
            });

            // 设置清空联系人列表按钮事件
            document.getElementById('clearContactsBtn').addEventListener('click', () => {
                UserManager.clearAllContacts();
            });

            document.getElementById('cancelNewChatBtn').addEventListener('click', () => {
                document.getElementById('newChatForm').style.display = 'none';
                document.getElementById('peerIdInput').value = '';
                document.getElementById('peerNameInput').value = '';
            });

            document.getElementById('confirmNewChatBtn').addEventListener('click', () => {
                const peerId = document.getElementById('peerIdInput').value.trim();
                const peerName = document.getElementById('peerNameInput').value.trim() || `用户${peerId.substring(0, 4)}`;

                if (!peerId) {
                    UIManager.showNotification('请输入对方ID', 'warning');
                    return;
                }

                if (UserManager.addContact(peerId, peerName)) {
                    document.getElementById('newChatForm').style.display = 'none';
                    document.getElementById('peerIdInput').value = '';
                    document.getElementById('peerNameInput').value = '';

                    // 切换到联系人列表
                    document.querySelector('.connection-tab[data-tab="chats"]').click();
                }
            });

            // 设置选项卡切换
            document.querySelectorAll('.connection-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.connection-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const tabName = tab.getAttribute('data-tab');
                    document.querySelectorAll('.connection-panel').forEach(panel => {
                        panel.classList.remove('active');
                    });
                    document.getElementById(`${tabName}Panel`).classList.add('active');
                });
            });
        },

        loadChats: async function() {
            try {
                await DBManager.init();
                const chatItems = await DBManager.getAllItems('chats');
                this.chats = {};

                if (chatItems && chatItems.length > 0) {
                    chatItems.forEach(item => {
                        this.chats[item.id] = item.messages || [];
                    });
                }
            } catch (error) {
                Utils.log(`加载聊天记录失败: ${error}`, Utils.logLevels.ERROR);
                // 尝试从localStorage加载
                this.loadChatsFromLocalStorage();
            }
        },

        saveChats: async function() {
            if (this.currentChatId) {
                try {
                    await DBManager.setItem('chats', {
                        id: this.currentChatId,
                        messages: this.chats[this.currentChatId] || []
                    });

                } catch (error) {
                    Utils.log(`保存聊天记录失败: ${error}`, Utils.logLevels.ERROR);
                }
            }
        },

        renderChatList: function() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';

            const sortedContacts = Object.values(UserManager.contacts).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedContacts.length === 0) {
                chatList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">暂无聊天，点击"添加新聊天"开始</div>';
                return;
            }

            sortedContacts.forEach(contact => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${contact.id === this.currentChatId ? 'active' : ''}`;
                chatItem.setAttribute('data-id', contact.id);

                const lastTime = new Date(contact.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                chatItem.innerHTML = `
            <div class="chat-avatar">${contact.name.charAt(0)}</div>
            <div class="chat-info">
                <div class="chat-name">${contact.name}</div>
                <div class="chat-preview">${contact.lastMessage || '暂无消息'}</div>
            </div>
            <div class="chat-meta">
                <div class="chat-time">${formattedTime}</div>
                ${contact.unread ? `<div class="chat-badge">${contact.unread > 99 ? '99+' : contact.unread}</div>` : ''}
            </div>
            <div class="delete-btn" style="display: none;">删除</div>
        `;

                chatItem.addEventListener('click', (e) => {
                    // 如果点击的是删除按钮，不打开聊天
                    if (e.target.classList.contains('delete-btn')) {
                        e.stopPropagation();
                        this.deleteChat(contact.id);
                        return;
                    }
                    this.openChat(contact.id);
                });

                // 添加鼠标悬浮事件
                chatItem.addEventListener('mouseenter', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'block';
                });

                chatItem.addEventListener('mouseleave', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'none';
                });

                chatList.appendChild(chatItem);
            });
        },

        // 添加删除聊天记录的方法
        deleteChat: function(chatId) {
            // 确认对话框
            if (confirm('确定要删除此聊天吗？此操作将清空聊天记录且不可撤销。')) {
                // 清空聊天记录
                this.clearChat(chatId);

                // 从联系人列表中移除
                UserManager.removeContact(chatId);

                // 如果删除的是当前聊天，重置聊天界面
                if (chatId === this.currentChatId) {
                    this.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';

                    // 禁用聊天界面
                    UIManager.enableChatInterface(false);
                }

                // 更新联系人列表
                this.renderChatList();

                // 显示通知
                UIManager.showNotification('聊天已删除', 'info');
            }
        },

        openChat: function(chatId) {
            // 保存之前的聊天记录
            if (this.currentChatId) {
                this.saveCurrentChat();
            }

            this.currentChatId = chatId;

            // 检查是否是群聊
            if (chatId.startsWith('group_')) {
                // 如果是群聊，交给群聊管理器处理
                GroupManager.openGroup(chatId);
                return;
            }

            // 个人聊天处理逻辑
            UserManager.clearUnread(chatId);

            // 更新UI
            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.toggle('active', item.getAttribute('data-id') === chatId);
            });

            // 设置聊天标题
            const contact = UserManager.contacts[chatId];
            if (contact) {
                document.getElementById('currentChatTitle').textContent = contact.name;
            }

            // 隐藏群聊成员管理按钮
            document.getElementById('chatHeaderActions').style.display = 'none';

            // 加载聊天记录
            this.loadChatHistory(chatId);

            // 在移动设备上切换到聊天界面
            if (window.innerWidth <= 768) {
                document.querySelector('.container').classList.add('connected-mode');
            }

            // 启用聊天输入
            UIManager.enableChatInterface(true);

            // 检查连接状态
            const isConnected = ConnectionManager.isConnectedTo(chatId);

            // 更新视频通话按钮状态
            document.getElementById('videoCallButton').disabled = !isConnected;

            // 如果连接未建立，添加系统消息提示
            if (!isConnected) {
                const chatBox = document.getElementById('chatBox');
                const systemMessage = document.createElement('div');
                systemMessage.className = 'system-message';
                systemMessage.textContent = '连接未建立，发送消息时将提示重新连接';
                chatBox.appendChild(systemMessage);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            // 聚焦输入框
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        },

        loadChatHistory: function(chatId) {
            const chatBox = document.getElementById('chatBox');
            chatBox.innerHTML = '';

            if (!this.chats[chatId]) {
                this.chats[chatId] = [];
                return;
            }

            this.chats[chatId].forEach(msg => {
                MessageManager.displayMessage(msg, msg.sender === UserManager.userId);
            });

            // 滚动到底部
            chatBox.scrollTop = chatBox.scrollHeight;
        },

        saveCurrentChat: function() {
            if (this.currentChatId) {
                this.saveChats();
            }
        },

        addMessage: async function(chatId, message) {
            if (!this.chats[chatId]) {
                this.chats[chatId] = [];
            }

            this.chats[chatId].push(message);

            // 如果是当前聊天，显示消息
            if (chatId === this.currentChatId) {
                MessageManager.displayMessage(message, message.sender === UserManager.userId);
                document.getElementById('chatBox').scrollTop = document.getElementById('chatBox').scrollHeight;
            } else {
                // 更新未读消息计数
                if (chatId.startsWith('group_')) {
                    GroupManager.updateGroupLastMessage(
                        chatId,
                        message.type === 'text' ? message.content : '[媒体消息]',
                        true
                    );
                } else {
                    UserManager.updateContactLastMessage(
                        chatId,
                        message.type === 'text' ? message.content : '[媒体消息]',
                        true
                    );
                }
            }

            try {
                // 保存到IndexedDB
                await DBManager.setItem('chats', {
                    id: chatId,
                    messages: this.chats[chatId]
                });
            } catch (error) {
                Utils.log(`保存消息失败: ${error}`, Utils.logLevels.ERROR);
            }
        },

        clearChat: async function(chatId) {
            if (chatId) {
                this.chats[chatId] = [];

                try {
                    await DBManager.setItem('chats', {
                        id: chatId,
                        messages: []
                    });

                    if (chatId === this.currentChatId) {
                        document.getElementById('chatBox').innerHTML = '';
                    }

                    return true;
                } catch (error) {
                    Utils.log(`清空聊天记录失败: ${error}`, Utils.logLevels.ERROR);

                    if (chatId === this.currentChatId) {
                        document.getElementById('chatBox').innerHTML = '';
                    }

                    return true;
                }
            }
            return false;
        },

        // 清空所有聊天记录
        clearAllChats: async function() {
            // 确认对话框
            if (!confirm('确定要清空所有聊天记录吗？此操作不可撤销。')) {
                return;
            }

            // 清空所有聊天记录
            this.chats = {};

            try {
                await DBManager.clearStore('chats');

                // 如果当前有打开的聊天，清空聊天框
                if (this.currentChatId) {
                    document.getElementById('chatBox').innerHTML = '';

                    // 添加系统消息提示
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = '所有聊天记录已清空';
                    document.getElementById('chatBox').appendChild(systemMessage);
                }

                // 更新所有联系人的最后消息
                for (const contactId in UserManager.contacts) {
                    UserManager.contacts[contactId].lastMessage = '';
                    UserManager.contacts[contactId].unread = 0;
                }
                UserManager.saveContacts();

                // 更新群组的最后消息
                for (const groupId in GroupManager.groups) {
                    GroupManager.groups[groupId].lastMessage = '';
                    GroupManager.groups[groupId].unread = 0;
                }
                GroupManager.saveGroups();

                // 更新联系人列表
                this.renderChatList();

                // 通知用户
                UIManager.showNotification('所有聊天记录已清空', 'info');
                Utils.log('所有聊天记录已清空', Utils.logLevels.INFO);

                return true;
            } catch (error) {
                Utils.log(`清空所有聊天记录失败: ${error}`, Utils.logLevels.ERROR);

                // 如果当前有打开的聊天，清空聊天框
                if (this.currentChatId) {
                    document.getElementById('chatBox').innerHTML = '';

                    // 添加系统消息提示
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = '所有聊天记录已清空';
                    document.getElementById('chatBox').appendChild(systemMessage);
                }

                // 更新联系人列表
                this.renderChatList();

                return true;
            }
        }
    };

    // 用户管理器
    const UserManager = {
        userId: null,
        userName: '我',
        contacts: {},

        init: async function() {
            try {
                // 确保数据库初始化
                await DBManager.init();

                // 获取或生成用户ID
                const userData = await DBManager.getItem('user', 'current');
                if (userData) {
                    this.userId = userData.userId;
                } else {
                    // 生成新用户ID
                    this.userId = Utils.generateId();
                    await DBManager.setItem('user', {
                        id: 'current',
                        userId: this.userId
                    });
                }

                // 显示用户ID
                document.getElementById('userIdValue').textContent = this.userId;
                this.userName = this.userId;

                // 设置复制ID按钮
                document.getElementById('copyIdBtn').addEventListener('click', () => {
                    navigator.clipboard.writeText(this.userId)
                        .then(() => UIManager.showNotification('ID已复制到剪贴板', 'success'))
                        .catch(() => UIManager.showNotification('复制失败，请手动复制', 'error'));
                });

                // 加载联系人
                await this.loadContacts();
            } catch (error) {
                Utils.log(`用户初始化失败: ${error}`, Utils.logLevels.ERROR);
                // 回退方案
                this.userId = Utils.generateId();
                document.getElementById('userIdValue').textContent = this.userId;
                this.loadContactsFromLocalStorage();
            }
        },

        loadContacts: async function() {
            try {
                const contacts = await DBManager.getAllItems('contacts');
                this.contacts = {};

                if (contacts && contacts.length > 0) {
                    contacts.forEach(contact => {
                        this.contacts[contact.id] = contact;
                    });
                    ChatManager.renderChatList();
                }
            } catch (error) {
                Utils.log(`加载联系人失败: ${error}`, Utils.logLevels.ERROR);
                this.contacts = {};
                // 尝试从localStorage加载
                this.loadContactsFromLocalStorage();
            }
        },

        saveContacts: async function() {
            try {
                for (const id in this.contacts) {
                    await DBManager.setItem('contacts', this.contacts[id]);
                }
            } catch (error) {
                Utils.log(`保存联系人失败: ${error}`, Utils.logLevels.ERROR);
            }
        },

        addContact: async function(id, name) {
            if (id === this.userId) {
                UIManager.showNotification('不能添加自己为联系人', 'error');
                return false;
            }

            if (this.contacts[id]) {
                UIManager.showNotification('该联系人已存在', 'warning');
                return false;
            }

            const contact = {
                id: id,
                name: name || `用户${id.substring(0, 4)}`,
                lastMessage: '',
                lastTime: new Date().toISOString(),
                unread: 0
            };

            this.contacts[id] = contact;

            try {
                await DBManager.setItem('contacts', contact);
                ChatManager.renderChatList();
                return true;
            } catch (error) {
                Utils.log(`添加联系人失败: ${error}`, Utils.logLevels.ERROR);
                // 备份策略：保存到localStorage
                this.saveContacts();
                ChatManager.renderChatList();
                return true;
            }
        },

        removeContact: async function(id) {
            if (this.contacts[id]) {
                delete this.contacts[id];

                try {
                    await DBManager.removeItem('contacts', id);
                    ChatManager.renderChatList();
                    return true;
                } catch (error) {
                    Utils.log(`删除联系人失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份策略：保存到localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                    return true;
                }
            }
            return false;
        },

        updateContactLastMessage: async function(id, message, isUnread = false) {
            if (this.contacts[id]) {
                this.contacts[id].lastMessage = message;
                this.contacts[id].lastTime = new Date().toISOString();
                if (isUnread) {
                    this.contacts[id].unread = (this.contacts[id].unread || 0) + 1;
                }

                try {
                    await DBManager.setItem('contacts', this.contacts[id]);
                    ChatManager.renderChatList();
                } catch (error) {
                    Utils.log(`更新联系人最后消息失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份策略：保存到localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                }
            }
        },

        clearUnread: async function(id) {
            if (this.contacts[id]) {
                this.contacts[id].unread = 0;

                try {
                    await DBManager.setItem('contacts', this.contacts[id]);
                    ChatManager.renderChatList();
                } catch (error) {
                    Utils.log(`清除未读数失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份策略：保存到localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                }
            }
        },

        // 清空所有联系人列表
        clearAllContacts: async function() {
            // 确认对话框
            if (!confirm('确定要清空所有聊天吗？此操作不可撤销。')) {
                return false;
            }

            // 备份当前联系人ID，用于后续关闭连接
            const contactIds = Object.keys(this.contacts);

            // 清空联系人对象
            this.contacts = {};

            try {
                // 清空IndexedDB中的联系人
                await DBManager.clearStore('contacts');

                // 关闭所有连接
                contactIds.forEach(peerId => {
                    if (ConnectionManager.connections[peerId]) {
                        ConnectionManager.close(peerId);
                    }
                });

                // 更新UI
                ChatManager.renderChatList();

                // 清空当前聊天
                if (ChatManager.currentChatId) {
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';

                    // 禁用聊天界面
                    UIManager.enableChatInterface(false);
                }

                // 通知用户
                UIManager.showNotification('所有联系人已清空', 'info');
                Utils.log('所有联系人已清空', Utils.logLevels.INFO);

                return true;
            } catch (error) {
                Utils.log(`清空联系人失败: ${error}`, Utils.logLevels.ERROR);
                return true;
            }
        }
    };

    // 群聊管理器
    const GroupManager = {
        groups: {},
        currentGroupId: null,

        init: async function() {
            // 从数据库加载群聊
            await this.loadGroups();

            // 设置新建群聊按钮事件
            document.getElementById('newGroupBtn').addEventListener('click', () => {
                document.getElementById('newGroupForm').style.display = 'block';
            });

            document.getElementById('cancelNewGroupBtn').addEventListener('click', () => {
                document.getElementById('newGroupForm').style.display = 'none';
                document.getElementById('groupNameInput').value = '';
            });

            document.getElementById('confirmNewGroupBtn').addEventListener('click', () => {
                const groupName = document.getElementById('groupNameInput').value.trim();

                if (!groupName) {
                    UIManager.showNotification('请输入群聊名称', 'warning');
                    return;
                }

                this.createGroup(groupName);
                document.getElementById('newGroupForm').style.display = 'none';
                document.getElementById('groupNameInput').value = '';
            });

            // 设置成员管理
            document.getElementById('manageMembersBtn').addEventListener('click', () => {
                this.showMemberManagement();
            });

            document.getElementById('addMemberBtn').addEventListener('click', () => {
                const contactId = document.getElementById('contactsDropdown').value;
                if (contactId) {
                    this.addMemberToGroup(this.currentGroupId, contactId);
                }
            });

            // 关闭模态窗口
            document.querySelector('.close-modal').addEventListener('click', () => {
                document.getElementById('memberManagementModal').style.display = 'none';
            });

            // 点击模态窗口外部关闭
            window.addEventListener('click', (event) => {
                const modal = document.getElementById('memberManagementModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        },

        loadGroups: async function() {
            try {
                await DBManager.init();
                const groupItems = await DBManager.getAllItems('groups');
                this.groups = {};

                if (groupItems && groupItems.length > 0) {
                    groupItems.forEach(group => {
                        this.groups[group.id] = group;
                    });
                    this.renderGroupList();
                }
            } catch (error) {
                Utils.log(`加载群聊失败: ${error}`, Utils.logLevels.ERROR);
                // 尝试从localStorage加载
                this.loadGroupsFromLocalStorage();
            }
        },

        saveGroups: async function() {
            try {
                for (const id in this.groups) {
                    await DBManager.setItem('groups', this.groups[id]);
                }
            } catch (error) {
                Utils.log(`保存群聊失败: ${error}`, Utils.logLevels.ERROR);
            }
        },

        createGroup: async function(name) {
            const groupId = 'group_' + Utils.generateId();
            const group = {
                id: groupId,
                name: name,
                owner: UserManager.userId,
                members: [UserManager.userId],
                lastMessage: '',
                lastTime: new Date().toISOString(),
                unread: 0
            };

            this.groups[groupId] = group;

            try {
                await DBManager.setItem('groups', group);
                this.renderGroupList();
                UIManager.showNotification(`群聊"${name}"已创建`, 'success');
                return groupId;
            } catch (error) {
                Utils.log(`创建群聊失败: ${error}`, Utils.logLevels.ERROR);
                // 备份到localStorage
                this.saveGroups();
                this.renderGroupList();
                UIManager.showNotification(`群聊"${name}"已创建`, 'success');
                return groupId;
            }
        },

        renderChatList: function() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';

            const sortedContacts = Object.values(UserManager.contacts).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedContacts.length === 0) {
                chatList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">暂无聊天，点击"添加新聊天"开始</div>';
                return;
            }

            sortedContacts.forEach(contact => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${contact.id === this.currentChatId ? 'active' : ''}`;
                chatItem.setAttribute('data-id', contact.id);

                const lastTime = new Date(contact.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                chatItem.innerHTML = `
            <div class="chat-avatar">${contact.name.charAt(0)}</div>
            <div class="chat-info">
                <div class="chat-name">${contact.name}</div>
                <div class="chat-preview">${contact.lastMessage || '暂无消息'}</div>
            </div>
            <div class="chat-meta">
                <div class="chat-time">${formattedTime}</div>
                ${contact.unread ? `<div class="chat-badge">${contact.unread > 99 ? '99+' : contact.unread}</div>` : ''}
            </div>
            <div class="delete-btn" style="display: none;">删除</div>
        `;

                chatItem.addEventListener('click', (e) => {
                    // 如果点击的是删除按钮，不打开聊天
                    if (e.target.classList.contains('delete-btn')) {
                        e.stopPropagation();
                        this.deleteChat(contact.id);
                        return;
                    }
                    this.openChat(contact.id);
                });

                // 添加鼠标悬浮事件
                chatItem.addEventListener('mouseenter', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'block';
                });

                chatItem.addEventListener('mouseleave', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'none';
                });

                chatList.appendChild(chatItem);
            });
        },

        deleteChat: function(chatId) {
            // 确认对话框
            if (confirm('确定要删除此聊天吗？此操作将清空聊天记录且不可撤销。')) {
                // 清空聊天记录
                this.clearChat(chatId);

                // 从联系人列表中移除
                UserManager.removeContact(chatId);

                // 如果删除的是当前聊天，重置聊天界面
                if (chatId === this.currentChatId) {
                    this.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';

                    // 禁用聊天界面
                    UIManager.enableChatInterface(false);
                }

                // 更新联系人列表
                this.renderChatList();

                // 显示通知
                UIManager.showNotification('聊天已删除', 'info');
            }
        },

        openGroup: function(groupId) {
            // 保存之前的聊天记录
            if (ChatManager.currentChatId) {
                ChatManager.saveCurrentChat();
            }

            ChatManager.currentChatId = groupId;
            this.currentGroupId = groupId;
            this.clearUnread(groupId);

            // 更新UI
            document.querySelectorAll('.group-item').forEach(item => {
                item.classList.toggle('active', item.getAttribute('data-id') === groupId);
            });

            // 设置聊天标题
            const group = this.groups[groupId];
            if (group) {
                document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;

                // 显示成员管理按钮（仅群主可见）
                const chatHeaderActions = document.getElementById('chatHeaderActions');
                if (group.owner === UserManager.userId) {
                    chatHeaderActions.style.display = 'flex';
                } else {
                    chatHeaderActions.style.display = 'none';
                }
            }

            // 加载聊天记录
            ChatManager.loadChatHistory(groupId);

            // 在移动设备上切换到聊天界面
            if (window.innerWidth <= 768) {
                document.querySelector('.container').classList.add('connected-mode');
            }

            // 启用聊天输入
            UIManager.enableChatInterface(true);

            // 聚焦输入框
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        },

        addMemberToGroup: async function(groupId, memberId) {
            const group = this.groups[groupId];
            if (!group) return false;

            // 检查是否已经是成员
            if (group.members.includes(memberId)) {
                UIManager.showNotification('该用户已在群聊中', 'warning');
                return false;
            }

            // 检查是否已连接
            if (!ConnectionManager.isConnectedTo(memberId)) {
                UIManager.showNotification('请先与该用户建立连接', 'warning');
                return false;
            }

            // 添加成员
            group.members.push(memberId);

            try {
                await DBManager.setItem('groups', group);

                // 更新成员管理界面
                this.showMemberManagement();

                // 更新群聊标题
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;
                }

                // 发送系统消息
                const systemMessage = {
                    type: 'system',
                    content: `${UserManager.contacts[memberId]?.name || memberId} 已加入群聊`,
                    timestamp: new Date().toISOString()
                };

                // 添加到聊天记录
                ChatManager.addMessage(groupId, systemMessage);

                // 通知新成员已加入群聊
                const groupInfo = {
                    type: 'group-invite',
                    groupId: groupId,
                    groupName: group.name,
                    members: group.members,
                    owner: group.owner,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                ConnectionManager.sendTo(memberId, groupInfo);

                // 通知其他成员有新成员加入
                const memberUpdate = {
                    type: 'group-member-added',
                    groupId: groupId,
                    newMemberId: memberId,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                this.broadcastToGroup(groupId, memberUpdate, [memberId]);

                UIManager.showNotification(`已将 ${UserManager.contacts[memberId]?.name || memberId} 添加到群聊`, 'success');
                return true;
            } catch (error) {
                Utils.log(`添加群聊成员失败: ${error}`, Utils.logLevels.ERROR);
                // 备份到localStorage
                this.saveGroups();
                return true;
            }
        },

        removeMemberFromGroup: async function(groupId, memberId) {
            const group = this.groups[groupId];
            if (!group) return false;

            // 检查是否是群主
            if (group.owner !== UserManager.userId) {
                UIManager.showNotification('只有群主可以移除成员', 'error');
                return false;
            }

            // 移除成员
            const index = group.members.indexOf(memberId);
            if (index !== -1) {
                group.members.splice(index, 1);

                try {
                    await DBManager.setItem('groups', group);

                    // 更新成员管理界面
                    this.showMemberManagement();

                    // 更新群聊标题
                    if (this.currentGroupId === groupId) {
                        document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;
                    }

                    // 发送系统消息
                    const systemMessage = {
                        type: 'system',
                        content: `${UserManager.contacts[memberId]?.name || memberId} 已被移出群聊`,
                        timestamp: new Date().toISOString()
                    };

                    // 添加到聊天记录
                    ChatManager.addMessage(groupId, systemMessage);

                    // 通知被移除的成员
                    const removeNotification = {
                        type: 'group-removed',
                        groupId: groupId,
                        reason: 'removed_by_owner',
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };

                    if (ConnectionManager.isConnectedTo(memberId)) {
                        ConnectionManager.sendTo(memberId, removeNotification);
                    }

                    // 通知其他成员
                    const memberUpdate = {
                        type: 'group-member-removed',
                        groupId: groupId,
                        removedMemberId: memberId,
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };

                    this.broadcastToGroup(groupId, memberUpdate);

                    UIManager.showNotification(`已将 ${UserManager.contacts[memberId]?.name || memberId} 移出群聊`, 'success');
                    return true;
                } catch (error) {
                    Utils.log(`移除群聊成员失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份到localStorage
                    this.saveGroups();
                    return true;
                }
            }

            return false;
        },

        clearUnread: async function(groupId) {
            if (this.groups[groupId]) {
                this.groups[groupId].unread = 0;

                try {
                    await DBManager.setItem('groups', this.groups[groupId]);
                    this.renderGroupList();
                } catch (error) {
                    Utils.log(`清除群聊未读数失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份到localStorage
                    this.saveGroups();
                    this.renderGroupList();
                }
            }
        },

        updateGroupLastMessage: async function(groupId, message, isUnread = false) {
            if (this.groups[groupId]) {
                this.groups[groupId].lastMessage = message;
                this.groups[groupId].lastTime = new Date().toISOString();
                if (isUnread) {
                    this.groups[groupId].unread = (this.groups[groupId].unread || 0) + 1;
                }

                try {
                    await DBManager.setItem('groups', this.groups[groupId]);
                    this.renderGroupList();
                } catch (error) {
                    Utils.log(`更新群聊最后消息失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份到localStorage
                    this.saveGroups();
                    this.renderGroupList();
                }
            }
        },

        handleGroupInvite: async function(message) {
            // 创建或更新本地群组信息
            this.groups[message.groupId] = {
                id: message.groupId,
                name: message.groupName,
                owner: message.owner,
                members: message.members,
                lastMessage: '您被邀请加入群聊',
                lastTime: message.timestamp,
                unread: 1
            };

            try {
                await DBManager.setItem('groups', this.groups[message.groupId]);
                this.renderGroupList();

                // 显示通知
                UIManager.showNotification(`您已被邀请加入群聊"${message.groupName}"`, 'info');
            } catch (error) {
                Utils.log(`保存群聊邀请失败: ${error}`, Utils.logLevels.ERROR);
                // 备份到localStorage
                this.saveGroups();
                this.renderGroupList();

                // 显示通知
                UIManager.showNotification(`您已被邀请加入群聊"${message.groupName}"`, 'info');
            }
        },

        handleGroupRemoval: async function(message) {
            const groupId = message.groupId;

            // 如果群组存在，移除它
            if (this.groups[groupId]) {
                // 如果当前正在查看该群组，关闭它
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';
                }

                try {
                    // 删除群组
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];
                    this.renderGroupList();

                    // 显示通知
                    UIManager.showNotification('您已被移出群聊', 'warning');
                } catch (error) {
                    Utils.log(`处理群聊移除失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份到localStorage
                    delete this.groups[groupId];
                    this.saveGroups();
                    this.renderGroupList();

                    // 显示通知
                    UIManager.showNotification('您已被移出群聊', 'warning');
                }
            }
        },

        // 修改消息数据结构
        broadcastToGroup: function(groupId, message, excludeMembers = []) {
            const group = this.groups[groupId];
            if (!group) return false;

            // 确保消息有发送者信息
            if (!message.sender) {
                message.sender = UserManager.userId;
            }

            // 添加原始发送者信息，用于追踪消息真实来源
            message.originalSender = message.sender;
            message.originalSenderName = UserManager.userName;

            // 确保消息有时间戳
            if (!message.timestamp) {
                message.timestamp = new Date().toISOString();
            }

            // 添加群组ID
            message.groupId = groupId;

            // 如果是群主，直接向所有成员广播
            if (group.owner === UserManager.userId) {
                let successCount = 0;

                // 向每个成员发送消息（排除自己和可能的排除列表）
                group.members.forEach(memberId => {
                    if (memberId !== UserManager.userId && !excludeMembers.includes(memberId)) {
                        if (ConnectionManager.isConnectedTo(memberId)) {
                            // 发送文件消息需要使用sendInChunks
                            if (message.type === 'file' || message.type === 'image' || message.type === 'audio') {
                                Utils.sendInChunks(JSON.stringify(message),
                                    (data) => ConnectionManager.connections[memberId].dataChannel.send(data));
                            } else {
                                ConnectionManager.sendTo(memberId, message);
                            }
                            successCount++;
                        }
                    }
                });

                return successCount > 0;
            }
            // 如果不是群主，将消息发送给群主，由群主转发
            else if (ConnectionManager.isConnectedTo(group.owner)) {
                // 添加转发标记，表示这是需要群主转发的消息
                message.needsRelay = true;

                // 发送文件消息需要使用sendInChunks
                if (message.type === 'file' || message.type === 'image' || message.type === 'audio') {
                    Utils.sendInChunks(JSON.stringify(message),
                        (data) => ConnectionManager.connections[group.owner].dataChannel.send(data));
                    return true;
                } else {
                    return ConnectionManager.sendTo(group.owner, message);
                }
            }

            return false;
        },

        renderGroupList: function() {
            const groupList = document.getElementById('groupList');
            groupList.innerHTML = '';

            const sortedGroups = Object.values(this.groups).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedGroups.length === 0) {
                groupList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">暂无群聊，点击"创建新群聊"开始</div>';
                return;
            }

            sortedGroups.forEach(group => {
                const groupItem = document.createElement('div');
                groupItem.className = `group-item ${group.id === this.currentGroupId ? 'active' : ''}`;
                groupItem.setAttribute('data-id', group.id);

                const lastTime = new Date(group.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                // 判断是群主还是普通成员
                const isOwner = group.owner === UserManager.userId;
                const buttonText = isOwner ? '群解散' : '退群';
                const buttonClass = isOwner ? 'dissolve-btn' : 'leave-btn';

                groupItem.innerHTML = `
            <div class="group-avatar">👥</div>
            <div class="group-info">
                <div class="group-name">${group.name}</div>
                <div class="group-preview">${group.members.length}人 | ${group.lastMessage || '暂无消息'}</div>
            </div>
            <div class="group-meta">
                <div class="group-time">${formattedTime}</div>
                ${group.unread ? `<div class="chat-badge">${group.unread > 99 ? '99+' : group.unread}</div>` : ''}
            </div>
            <div class="${buttonClass}" style="display: none;">${buttonText}</div>
        `;

                groupItem.addEventListener('click', (e) => {
                    // 如果点击的是按钮，不打开群聊
                    if (e.target.classList.contains('leave-btn')) {
                        e.stopPropagation();
                        this.leaveGroup(group.id);
                        return;
                    } else if (e.target.classList.contains('dissolve-btn')) {
                        e.stopPropagation();
                        this.dissolveGroup(group.id);
                        return;
                    }
                    this.openGroup(group.id);
                });

                // 添加鼠标悬浮事件
                groupItem.addEventListener('mouseenter', () => {
                    groupItem.querySelector(`.${buttonClass}`).style.display = 'block';
                });

                groupItem.addEventListener('mouseleave', () => {
                    groupItem.querySelector(`.${buttonClass}`).style.display = 'none';
                });

                groupList.appendChild(groupItem);
            });
        },

        // 修改leaveGroup方法，添加系统消息通知其他成员
        leaveGroup: async function(groupId) {
            if (confirm('确定要退出此群聊吗？此操作不可撤销。')) {
                const group = this.groups[groupId];
                if (!group) return;

                // 获取用户名称
                let userName = UserManager.userName;
                if (UserManager.contacts[UserManager.userId]) {
                    userName = UserManager.contacts[UserManager.userId].name;
                }

                // 从成员列表中移除自己
                const index = group.members.indexOf(UserManager.userId);
                if (index !== -1) {
                    // 创建系统消息，通知其他成员
                    const systemMessage = {
                        type: 'system',
                        content: `${userName} 已退出群聊`,
                        timestamp: new Date().toISOString(),
                        sender: UserManager.userId
                    };

                    // 广播系统消息给群组其他成员
                    this.broadcastToGroup(groupId, systemMessage);

                    // 通知群主此成员已退出（便于群主识别并可以重新添加）
                    const leaveMessage = {
                        type: 'group-member-left',
                        groupId: groupId,
                        leftMemberId: UserManager.userId,
                        leftMemberName: userName,
                        timestamp: new Date().toISOString(),
                        sender: UserManager.userId
                    };
                    this.broadcastToGroup(groupId, leaveMessage);

                    // 清空群聊记录
                    await ChatManager.clearChat(groupId);

                    // 从群组中删除
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];

                    // 如果当前正在查看该群聊，重置聊天界面
                    if (this.currentGroupId === groupId) {
                        this.currentGroupId = null;
                        ChatManager.currentChatId = null;
                        document.getElementById('currentChatTitle').textContent = '未选择聊天';
                        document.getElementById('chatBox').innerHTML = '';
                        document.getElementById('chatHeaderActions').style.display = 'none';

                        // 禁用聊天界面
                        UIManager.enableChatInterface(false);
                    }

                    // 更新群聊列表
                    this.renderGroupList();

                    // 显示通知
                    UIManager.showNotification('已退出群聊', 'info');
                }
            }
        },

        // 修改handleMembershipUpdate方法，处理成员退出事件
        handleMembershipUpdate: async function(message) {
            const groupId = message.groupId;
            const group = this.groups[groupId];

            if (!group) return;

            // 更新成员列表
            if (message.type === 'group-member-added' && message.newMemberId) {
                if (!group.members.includes(message.newMemberId)) {
                    group.members.push(message.newMemberId);
                }
            } else if (message.type === 'group-member-removed' && message.removedMemberId) {
                const index = group.members.indexOf(message.removedMemberId);
                if (index !== -1) {
                    group.members.splice(index, 1);
                }
            } else if (message.type === 'group-member-left' && message.leftMemberId) {
                const index = group.members.indexOf(message.leftMemberId);
                if (index !== -1) {
                    group.members.splice(index, 1);

                    // 如果当前用户是群主，记录退出成员的信息，以便重新添加
                    if (group.owner === UserManager.userId) {
                        // 保存退出成员信息到群组数据中
                        if (!group.leftMembers) {
                            group.leftMembers = [];
                        }

                        group.leftMembers.push({
                            id: message.leftMemberId,
                            name: message.leftMemberName || `用户${message.leftMemberId.substring(0, 4)}`,
                            leftTime: message.timestamp
                        });
                    }
                }
            }

            try {
                await DBManager.setItem('groups', group);

                // 如果当前正在查看该群组，更新标题
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;
                }
            } catch (error) {
                Utils.log(`更新群聊成员失败: ${error}`, Utils.logLevels.ERROR);
                // 备份到localStorage
                this.saveGroups();

                // 如果当前正在查看该群组，更新标题
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;
                }
            }
        },

        // 修改showMemberManagement方法，添加已退出成员列表
        showMemberManagement: function() {
            if (!this.currentGroupId) return;

            const group = this.groups[this.currentGroupId];
            if (!group) return;

            // 填充成员列表
            const memberList = document.getElementById('groupMemberList');
            memberList.innerHTML = '';

            group.members.forEach(memberId => {
                const memberItem = document.createElement('div');
                memberItem.className = 'member-item';

                // 确定成员名称
                let memberName = memberId;
                if (memberId === UserManager.userId) {
                    memberName = `${UserManager.userName} (我)`;
                } else if (UserManager.contacts[memberId]) {
                    memberName = UserManager.contacts[memberId].name;
                }

                // 标记群主
                const isOwner = memberId === group.owner;

                memberItem.innerHTML = `
            <div class="member-name">${memberName} ${isOwner ? '<span class="owner-badge">群主</span>' : ''}</div>
            ${!isOwner && group.owner === UserManager.userId ?
                    `<button class="remove-member-btn" data-id="${memberId}">移除</button>` : ''}
        `;

                memberList.appendChild(memberItem);
            });

            // 为移除按钮添加事件
            memberList.querySelectorAll('.remove-member-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const memberId = e.target.getAttribute('data-id');
                    this.removeMemberFromGroup(this.currentGroupId, memberId);
                });
            });

            // 添加已退出成员列表（仅群主可见）
            if (group.owner === UserManager.userId && group.leftMembers && group.leftMembers.length > 0) {
                const leftMembersSection = document.createElement('div');
                leftMembersSection.className = 'left-members-section';
                leftMembersSection.innerHTML = '<h4>已退出成员</h4>';

                const leftMembersList = document.createElement('div');
                leftMembersList.className = 'left-members-list';

                group.leftMembers.forEach(member => {
                    const leftMemberItem = document.createElement('div');
                    leftMemberItem.className = 'left-member-item';

                    // 格式化退出时间
                    const leftTime = new Date(member.leftTime);
                    const formattedTime = Utils.formatDate(leftTime);

                    leftMemberItem.innerHTML = `
                <div class="left-member-info">
                    <div class="left-member-name">${member.name}</div>
                    <div class="left-member-time">退出时间: ${formattedTime}</div>
                </div>
                <button class="readd-member-btn" data-id="${member.id}" data-name="${member.name}">重新添加</button>
            `;

                    leftMembersList.appendChild(leftMemberItem);
                });

                leftMembersSection.appendChild(leftMembersList);
                memberList.appendChild(leftMembersSection);

                // 为重新添加按钮添加事件
                memberList.querySelectorAll('.readd-member-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const memberId = e.target.getAttribute('data-id');
                        const memberName = e.target.getAttribute('data-name');
                        this.readdMemberToGroup(this.currentGroupId, memberId, memberName);
                    });
                });
            }

            // 填充联系人下拉列表
            const contactsDropdown = document.getElementById('contactsDropdown');
            contactsDropdown.innerHTML = '<option value="">选择联系人...</option>';

            Object.values(UserManager.contacts).forEach(contact => {
                // 只显示未加入群的联系人
                if (!group.members.includes(contact.id)) {
                    const option = document.createElement('option');
                    option.value = contact.id;
                    option.textContent = contact.name;
                    contactsDropdown.appendChild(option);
                }
            });

            // 显示模态窗口
            document.getElementById('memberManagementModal').style.display = 'block';
        },

        // 添加重新添加成员方法
        readdMemberToGroup: async function(groupId, memberId, memberName) {
            const group = this.groups[groupId];
            if (!group) return false;

            // 检查是否是群主
            if (group.owner !== UserManager.userId) {
                UIManager.showNotification('只有群主可以添加成员', 'error');
                return false;
            }

            // 检查是否已经是成员
            if (group.members.includes(memberId)) {
                UIManager.showNotification('该用户已在群聊中', 'warning');
                return false;
            }

            // 检查是否已连接
            if (!ConnectionManager.isConnectedTo(memberId)) {
                UIManager.showNotification('请先与该用户建立连接', 'warning');
                return false;
            }

            // 添加成员
            group.members.push(memberId);

            // 从leftMembers中移除
            if (group.leftMembers) {
                group.leftMembers = group.leftMembers.filter(member => member.id !== memberId);
            }

            try {
                await DBManager.setItem('groups', group);

                // 更新成员管理界面
                this.showMemberManagement();

                // 更新群聊标题
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}人)`;
                }

                // 发送系统消息
                const systemMessage = {
                    type: 'system',
                    content: `${memberName || memberId} 已被重新添加到群聊`,
                    timestamp: new Date().toISOString()
                };

                // 添加到聊天记录
                ChatManager.addMessage(groupId, systemMessage);

                // 通知新成员已加入群聊
                const groupInfo = {
                    type: 'group-invite',
                    groupId: groupId,
                    groupName: group.name,
                    members: group.members,
                    owner: group.owner,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                ConnectionManager.sendTo(memberId, groupInfo);

                // 通知其他成员有新成员加入
                const memberUpdate = {
                    type: 'group-member-added',
                    groupId: groupId,
                    newMemberId: memberId,
                    newMemberName: memberName,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                this.broadcastToGroup(groupId, memberUpdate, [memberId]);

                UIManager.showNotification(`已将 ${memberName || memberId} 重新添加到群聊`, 'success');
                return true;
            } catch (error) {
                Utils.log(`重新添加群聊成员失败: ${error}`, Utils.logLevels.ERROR);
                // 备份到localStorage
                this.saveGroups();
                return true;
            }
        },

        // 群主解散群聊方法
        dissolveGroup: async function(groupId) {
            if (confirm('确定要解散此群聊吗？所有成员将被移出，且此操作不可撤销。')) {
                const group = this.groups[groupId];
                if (!group || group.owner !== UserManager.userId) return;

                // 通知所有成员群聊已解散
                const dissolveMessage = {
                    type: 'group-dissolved',
                    groupId: groupId,
                    timestamp: new Date().toISOString(),
                    sender: UserManager.userId
                };
                this.broadcastToGroup(groupId, dissolveMessage);

                // 清空群聊记录
                await ChatManager.clearChat(groupId);

                // 从群组中删除
                await DBManager.removeItem('groups', groupId);
                delete this.groups[groupId];

                // 如果当前正在查看该群聊，重置聊天界面
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';

                    // 禁用聊天界面
                    UIManager.enableChatInterface(false);
                }

                // 更新群聊列表
                this.renderGroupList();

                // 显示通知
                UIManager.showNotification('群聊已解散', 'info');
            }
        },

        // 修改handleGroupMessage方法，添加处理群解散和成员退出的逻辑
        handleGroupMessage: function(message) {
            const groupId = message.groupId;

            // 检查是否是群组消息
            if (!groupId || !message.type) return false;

            // 如果是群主收到的消息，且需要转发
            if (message.needsRelay) {
                const group = this.groups[groupId];
                if (group && group.owner === UserManager.userId) {
                    // 移除转发标记，防止循环转发
                    delete message.needsRelay;

                    // 转发时保留原始发送者信息
                    // 群主转发消息时，不修改sender，确保消息显示的是真实发送者
                    this.broadcastToGroup(groupId, message, [message.originalSender]);
                }
            }

            // 处理不同类型的群组消息
            switch (message.type) {
                case 'group-invite':
                    // 处理群组邀请
                    this.handleGroupInvite(message);
                    break;

                case 'group-removed':
                    // 处理被移出群组
                    this.handleGroupRemoval(message);
                    break;

                case 'group-dissolved':
                    // 处理群组解散
                    this.handleGroupDissolved(message);
                    break;

                case 'group-member-added':
                case 'group-member-removed':
                case 'group-member-left':
                    // 更新群组成员信息
                    this.handleMembershipUpdate(message);
                    break;

                case 'text':
                case 'file':
                case 'image':
                case 'audio':
                    // 处理普通消息
                    if (this.groups[groupId]) {
                        // 添加到聊天记录，保留原始发送者信息
                        ChatManager.addMessage(groupId, message);

                        // 更新群组最后消息
                        let previewText = '';
                        const displayName = message.originalSenderName ||
                            (UserManager.contacts[message.originalSender]?.name) ||
                            '用户';

                        if (message.type === 'text') {
                            previewText = `${displayName}: ${message.content}`;
                        } else if (message.type === 'file' || message.type === 'image') {
                            if (message.fileType?.startsWith('image/')) {
                                previewText = `${displayName}: [图片]`;
                            } else if (message.fileType?.startsWith('video/')) {
                                previewText = `${displayName}: [视频]`;
                            } else if (message.fileType?.startsWith('audio/')) {
                                previewText = `${displayName}: [音频]`;
                            } else {
                                previewText = `${displayName}: [文件]`;
                            }
                        } else if (message.type === 'audio') {
                            previewText = `${displayName}: [语音]`;
                        }

                        this.updateGroupLastMessage(
                            groupId,
                            previewText,
                            this.currentGroupId !== groupId
                        );
                    }
                    break;

                case 'system':
                    // 处理系统消息
                    if (this.groups[groupId]) {
                        ChatManager.addMessage(groupId, message);
                    }
                    break;
            }

            return true;
        },

        // 处理群聊解散
        handleGroupDissolved: async function(message) {
            const groupId = message.groupId;

            // 如果群组存在且不是自己解散的，则处理解散消息
            if (this.groups[groupId] && message.sender !== UserManager.userId) {
                // 如果当前正在查看该群组，关闭它
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = '未选择聊天';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';

                    // 禁用聊天界面
                    UIManager.enableChatInterface(false);
                }

                try {
                    // 清空群聊记录
                    await ChatManager.clearChat(groupId);

                    // 删除群组
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];
                    this.renderGroupList();

                    // 显示通知
                    UIManager.showNotification('群主已解散群聊', 'warning');
                } catch (error) {
                    Utils.log(`处理群聊解散失败: ${error}`, Utils.logLevels.ERROR);
                    // 备份到localStorage
                    delete this.groups[groupId];
                    this.saveGroups();
                    this.renderGroupList();

                    // 显示通知
                    UIManager.showNotification('群主已解散群聊', 'warning');
                }
            }
        }

    };

    // 初始化应用
    const AppInitializer = {

        init: async function () {
            // 检查浏览器兼容性
            if (!UIManager.checkWebRTCSupport()) return;

            try {
                // 初始化IndexedDB
                await DBManager.init();
                Utils.log('数据库初始化成功', Utils.logLevels.INFO);

                // 初始化用户管理
                await UserManager.init();

                // 初始化聊天管理
                await ChatManager.init();

                // 检查网络状态
                this.checkNetworkType();

                // 添加网络状态监听
                this.startNetworkMonitoring();

                // 初始化语音录制按钮（但不申请权限）
                MediaManager.initVoiceRecording();

                // 初始化视频通话按钮（但不申请权限）
                VideoCallManager.init();

                // 添加按钮事件处理程序
                this.setupEventListeners();

                // 初始化移动端UI
                this.initMobileUI();

                // 初始化群聊管理
                await GroupManager.init();

                Utils.log('应用已初始化', Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`应用初始化失败: ${error}`, Utils.logLevels.ERROR);

                // 回退到localStorage模式
                Utils.log('回退到localStorage存储模式', Utils.logLevels.WARN);

                // 初始化用户管理
                UserManager.userId = Utils.generateId();
                document.getElementById('userIdValue').textContent = UserManager.userId;

                // 加载联系人
                UserManager.loadContactsFromLocalStorage();

                // 初始化聊天管理
                ChatManager.loadChatsFromLocalStorage();

                // 其他初始化步骤
                this.checkNetworkType();
                this.startNetworkMonitoring();
                MediaManager.initVoiceRecording();
                VideoCallManager.init();
                this.setupEventListeners();
                this.initMobileUI();

                // 加载群组
                GroupManager.loadGroupsFromLocalStorage();

                Utils.log('应用已使用localStorage模式初始化', Utils.logLevels.INFO);
            }
        },

        // 初始化移动端UI
        initMobileUI: function() {
            // 添加返回设置按钮事件
            const backButton = document.getElementById('backToSettings');
            if (backButton) {
                backButton.addEventListener('click', function() {
                    document.querySelector('.container').classList.remove('connected-mode');
                });
            }


            // 响应屏幕尺寸变化
            window.addEventListener('resize', function() {
                const container = document.querySelector('.container');
                const isConnected = document.getElementById('connectionStatus').classList.contains('connected');
                const sidebar = document.querySelector('.sidebar');

                // 如果是移动端且已连接，保持聊天界面显示
                if (window.innerWidth <= 768 && isConnected && ChatManager.currentChatId) {
                    // 显示进入聊天按钮
                    if (sidebar) sidebar.classList.add('show-back-btn');
                } else if (window.innerWidth > 768) {
                    // 在大屏幕上，移除连接模式类，显示两个面板
                    container.classList.remove('connected-mode');
                }
            });
        },

        // 检查网络状态
        checkNetworkType: async function () {
            const networkInfo = document.getElementById('networkInfo');
            networkInfo.innerHTML = '<span class="loading-spinner"></span> 正在检测网络...';

            try {
                const networkType = await Utils.checkNetworkType();

                if (networkType) {
                    let networkHtml = `
                    网络支持:<br>
                    IPv4: ${networkType.ipv4 ? '✓' : '✗'}<br>
                    IPv6: ${networkType.ipv6 ? '✓' : '✗'}<br>
                    UDP: ${networkType.udp ? '✓' : '✗'}<br>
                    TCP: ${networkType.tcp ? '✓' : '✗'}<br>
                    中继: ${networkType.relay ? '可用' : '未检测到'}<br>
                    候选数: ${networkType.count}
                `;

                    // 根据网络状况调整配置
                    if (!networkType.udp && networkType.tcp) {
                        Config.peerConnectionConfig.iceTransportPolicy = 'relay';
                        networkHtml += '<br><b>已切换到中继优先模式</b>';
                    }

                    networkInfo.innerHTML = networkHtml;

                    const qualityIndicator = document.getElementById('qualityIndicator');
                    if (qualityIndicator) {
                        if (networkType.udp) {
                            qualityIndicator.className = 'quality-indicator quality-good';
                            document.getElementById('qualityText').textContent = '网络良好';
                        } else if (networkType.tcp) {
                            qualityIndicator.className = 'quality-indicator quality-medium';
                            document.getElementById('qualityText').textContent = '网络受限';
                        } else {
                            qualityIndicator.className = 'quality-indicator quality-poor';
                            document.getElementById('qualityText').textContent = '网络受阻';
                        }
                    }
                } else {
                    networkInfo.innerHTML = '网络检测失败';
                }
            } catch (error) {
                networkInfo.innerHTML = '网络检测失败: ' + error.message;
            }
        },

        // 监听网络状态变化
        startNetworkMonitoring: function () {
            window.addEventListener('online', this.handleNetworkChange.bind(this));
            window.addEventListener('offline', this.handleNetworkChange.bind(this));
        },

        // 处理网络变化
        handleNetworkChange: function () {
            if (navigator.onLine) {
                UIManager.updateStatus('网络已恢复，尝试重新连接...');

                // 尝试重新连接所有活跃的连接
                for (const peerId in ConnectionManager.connections) {
                    const conn = ConnectionManager.connections[peerId];
                    if (conn && conn.peerConnection &&
                        conn.peerConnection.iceConnectionState !== 'connected') {
                        ConnectionManager.restartIce(peerId);
                    }
                }
            } else {
                UIManager.updateStatus('网络已断开');
            }
        },

        // 设置事件监听
        setupEventListeners: function () {
            // 消息输入框回车发送
            document.getElementById('messageInput').addEventListener('keydown', (e) => {
                // 如果是 Ctrl+Enter 组合键，则发送消息
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    MessageManager.sendMessage();
                }
                // 仅按回车键时，允许换行
                else if (e.key === 'Enter' && !e.ctrlKey) {
                    // 不阻止默认行为，允许输入换行符
                }
            });

            // 添加断开连接事件处理
            EventEmitter.on('connectionDisconnected', function(peerId) {
                // 如果是当前聊天，更新UI
                if (ChatManager.currentChatId === peerId) {
                    // 禁用视频通话按钮
                    document.getElementById('videoCallButton').disabled = true;
                    // 禁用音频通话按钮
                    document.getElementById('audioCallButton').disabled = true;

                    // 移动端：断开连接时切换回设置界面
                    if (window.innerWidth <= 768) {
                        document.querySelector('.container').classList.remove('connected-mode');
                    }
                }
            });

            EventEmitter.on('connectionEstablished', function(peerId) {
                // 如果是当前聊天，更新UI
                if (ChatManager.currentChatId === peerId) {
                    // 启用视频通话按钮
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);

                    // 启用音频通话按钮
                    document.getElementById('audioCallButton').disabled = false;
                    document.getElementById('audioCallButton').onclick = () => VideoCallManager.initiateAudioCall(peerId);
                }
            });

            EventEmitter.on('connectionFailed', function(peerId) {
                // 如果是当前聊天，更新UI
                if (ChatManager.currentChatId === peerId) {
                    // 禁用视频通话按钮
                    document.getElementById('videoCallButton').disabled = true;

                    // 移动端：连接失败时切换回设置界面
                    if (window.innerWidth <= 768) {
                        document.querySelector('.container').classList.remove('connected-mode');
                    }
                }
            });

            // 语音录制按钮事件
            const voiceButton = document.getElementById('voiceButton');

            // 检测是否为移动设备
            if ('ontouchstart' in window) {
                // 移动设备使用触摸事件
                voiceButton.addEventListener('touchstart', function (e) {
                    e.preventDefault();
                    MediaManager.startRecording();
                });

                voiceButton.addEventListener('touchend', function (e) {
                    e.preventDefault();
                    MediaManager.stopRecording();
                });
            } else {
                // 桌面设备使用鼠标事件
                voiceButton.addEventListener('mousedown', MediaManager.startRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseup', MediaManager.stopRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseleave', MediaManager.stopRecording.bind(MediaManager));
            }

            // 添加全局错误处理
            window.addEventListener('error', (event) => {
                Utils.log(`应用错误: ${event.message}`, Utils.logLevels.ERROR);
            });

            // 添加断开连接前的提示
            window.addEventListener('beforeunload', () => {
                // 释放语音录制资源
                MediaManager.releaseAudioResources();

                // 释放视频通话资源
                VideoCallManager.releaseMediaResources();

                // 关闭所有连接
                for (const peerId in ConnectionManager.connections) {
                    ConnectionManager.close(peerId);
                }
            });


            // 添加重置按钮事件
            document.getElementById('resetAllBtn').addEventListener('click', () => {
                UIManager.resetConnectionControls();
            });
        }
    };

    // 页面加载完成后初始化
    window.addEventListener('load', AppInitializer.init.bind(AppInitializer));
</script>
</html>